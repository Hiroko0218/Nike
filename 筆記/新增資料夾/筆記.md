# FOUNDATION01

### Java開發環境與搭建

#### 一、Java開發

#### Java是一款編程語言,編程語言是人類與計算機溝通的橋樑，Java只是編程語言中的一種

#### Java編譯運行過程:

- ##### 編譯期: JAVA源文件 -----經過編譯-----生成一個後綴為.class字節碼文件

- ##### 運行期: JVM主要負責加載並運行生成的.class字節碼文件

> Java語言的特點: 一次編譯,到處執行,跨平台
>
> Ｃ語言開發軟體要根據不同的軟體來開發不同的操作系統程序，因為操作系統底層處理的0和1不同！
>
> ​             ----不能跨平台，優點：運行效率高

#### 名詞解釋:

- ##### JVM: 主要負責加載並運行生成的.class字節碼文件

- ##### JRE :  Java運行環境，包含了JVM，還包含了運行Java程序所需要的工具

  - ##### JRE =  JVM  + Java類庫小工具

- ##### JDK:  Java開發工具包,包含 JRE，包含了 Java編譯運行等命令

  - ##### JDK = JRE  + 編譯運行的命令等

> 如果電腦只是想運行 Java程序，只需要給電腦安裝 JRE!
>
> 如果電腦想要開發 Java程序，必須需要 JDK!



### 編譯器工具

#### Eclipse(手動擋)      IDEA(自動擋)

#### IDEA是 JetBarins提供的工具,  社區版(免費)   和   終極版(收費)

#### 開源: 對用戶開放     ----- IDEA社區版      ------- JAVA語言開源 (源碼)

--------------

### Java開發步驟

- #### 新建一個項目	------------->  選小區樓盤項目

- #### 新建一個包        ------------->  樓＋單元

- #### 新建一個類        ------------->   房子

----

#### 注釋：只是對代碼的一種解釋性文本，注釋是給我們自己看的，所以注釋不會被編譯！

#### Java中的注釋分為三種：

- ##### 單行注釋:    // 解釋性的内容

- ##### 多行注釋:    /* 解釋性内容  */

- ##### 文擋注釋:   /** 解釋性内容 */

#### 第一個 JAVA程序：

```java
package day01; //包  包名 day01      ----------> 樓＋單元
/**
 * Java第一個程序演示類：
 */
public class HelloWorld {//類 類名 HelloWorld ---->房子
    //中大門指的是 運行程序的作用！
    //main功能：作用就是程序主入口，運行程序必須的語法！快捷鍵輸入法英文狀態下敲main，Enter即可！
    public static void main(String[] args) {
        /* 程序執行是逐語句執行！從 main的開始括號進入，直至到结束括號结束
            1.Java是嚴格區分大小寫的！
            2.寫代碼期間始終保持,輸入法英文狀態下！
            3.一行结尾要寫上分號 ;
         */
        //顯示打印的功能 ,作用就是可以將輸入的信息以程序方式呈現 快捷鍵：英文狀態下敲sout，Enter即可！
        //sout功能：將要顯示的内容寫在小括號中，數據整數，小數可以直接寫
        //除了數值數據以外的，例如字母,漢字,符號等 套在雙引號中寫！例如"hello Java！"
        System.out.println("hello,Java!");//雙引號的內容，所見即所得！
    }//程序執行到該行 則表示退出
    //運行程序,在當前界面空白區域 右鍵 選擇 綠色播放鍵 Run
}
```

##### 學習任何的技術點的內容，要問 1.這技術用來幹什麼？ 2.為什麼要學習？ 3.學完在哪裡用 (作用)？

### 變數

#### 早期的計算機  ---------------------算數 (數字的加減乘除)

#### 現在的計算機  ---------------------算數 (數字、圖片、文字、音檔、影片)

##### 計算機始終處理的數據，所以也就離不開變數，變數就是儲存數據用的。

#### 變數：就是用來存數的！

Java是強類型編譯語言，變數有著嚴格的語法約定：

1. 變數必須用明確的類型聲明

   a. 未經聲明的變數不能使用

   b. 變數的類型與數據類型匹配

2. 在第一次讀取使用變數前，必須使用賦值語句初始化

   a. 未經初始化的變數不能使用

3. 變數的值可以進行多次修改

4. 使用變數名獲取變數的值

   

- ##### 變數的聲明 : 去銀行開帳戶

```java
int a;    //聲明了一個int(用來存整數)的變數,變數名叫a
int b,c,d;//聲明了三個int(用來存整數)的變數,變數名分别為 b c d
//int a; 編譯錯誤，已存在變數名 a 
```

- ##### 變數的初始化: 為帳戶存錢 

> ##### =  在程序中表示 賦值號     賦值的順序：從右向左賦值

```java
int e = 300;//聲明了一個int(整數)的變數 名為e 並直接儲存300這個整數數據   聲明+初始化
int f;//聲明了一個int(整數)的變數 名為f
f = 500;//為f這個變數賦值500 這個數據
```

- ##### 變數的使用: 使用帳戶的錢

```java
int b = 5;////聲明了一個int(整數)的變數 名為b  並直接儲存5這個整數數據
int c = b + 10;
System.out.println("c");//字母 c
//System.out.println(C);//編譯錯誤：使用未聲明的變數C
System.out.println(c);//15
c = 25;
System.out.println(c);//25
```

```java
//整理代碼的快捷鍵：  ctrl + alt + L
//快速註釋當前選中行代碼： ctrl +  /
```

- ##### 命名規範
  - ##### 變數命名允許包含數字,字母,_和 $  ,且不能以數字開頭

  - ##### 變數命名不能有關鍵字(指的是係統中已存在的一些特殊的名字)

  - ##### 變數命名要求見名知意。

  - ##### 變數名存在多個單詞建議小駝峰命名法（單詞首字母小寫，第二個單詞首字母大寫...）

```java
//命名規范
        int $123abc_;//變數命名允許包含數字,字母,_和 $  ,且不能以數字開頭
//        int 123abc;變數命名不能以數字開頭
//        int class;變數命名不能有關鍵字(指的是係統中已存在的一些特殊的名字)白色主題是深藍色 黑色主題是橘黄
        int 年齡;//不是中文見名知意    變數命名要求見名知意
        int nianling;//不是拼音見名知意
        int age;//建議英文單詞的見名知意
        //多個單詞之間建議 小駝峰命名法
        int myAge;//單詞首字母小寫，第二個單詞首字母大寫,以此類推
        //類名要求 大駝峰命名法  單詞首字母大寫，第二個單詞首字母大寫,以此類推
```

### 數據類型

#### 作用: 決定了變數可以儲存的數據以及儲存的範圍.

#### 數據類型分為兩種: 基本數據類型  和 引用數據類型(後續講)

#### 基本數據類型有8種: byte , short , int , long    float ,double    char , boolean

#### 常用的基本數據類型:

##### 整數類型:int   long

##### 小數類型: double

##### 字元類型: char

##### 布爾類型: boolean

------------

##### GB(吉字元)

##### 1GB = 1024MB

##### MB(兆字元)

##### 1MB = 1024kb

#####  kb(千字元)

##### 1kb = 1024b

##### b(字元)

##### 1b  = 8bit

### 整數類型

#### int

> int類型在内存占用4個字元, 儲存範圍是 -21億 ~  21億

- ##### 整數直接量默認就是int類型,直接量是不可以超過當前類型所容納的範圍,否則會報編譯錯誤.

- ##### 整數運算時,结果是不會保留小數位的(截斷刪除)

- ##### 整數運算時,若運算结果超過當前類型所容納的範圍則會溢出(溢出不是錯誤),但是需要避免,因爲溢出的數據沒有参考價值

```java
          //100 就是整數直接量
        int a = 100;
        //最大值能存   2147483647  ~ 最小 -2147483648
//        int b = 2147483648; 直接量是不可以超過當前類型所容納的範圍,否則會報編譯錯誤.
        int b = 5;
        int c = 2;
        System.out.println( b / c);//2     整數運算時,结果是不會保留小數位的(截斷删除小數位)

        int e = 2147483647; //e 存的是int類型最大值
        int f = e + 3;
        System.out.println(f);//
        /**
         * 最大值+1  -------------->(-2147483648)
         * 最大值+1+1 ------------->(-2147483647)
         * 最大值+1+2 ------------->(-2147483646)
         */
```

```java
變數占用多大内存空間,取决是數據類型,而非裝載的數據!
int a = 5;
int b = 2147483647;
```

#### long

> long類型在内存中佔用8個字元,可以儲存-900萬萬億 ~  900萬萬億

- ##### 長整數類型的直接量,需要在直接量後加L.(明確表示是長整數直接量)

- ##### 長整數類型在進行運算時，建議在第一個數據後加L,那麼運算的結果則表示是long類型的结果.

```java
  //長整數直接量需要在直接量後加上L
        long b = 214748364800L;
                  //10億
        long c = 1000000000 * 2 * 10L;
        System.out.println(c);//200億
                //300億已經溢出了
        long d = 1000000000 * 3 * 10L;
        System.out.println(d);//溢出數據

        long f = 1000000000L * 3 * 10; //長整數類型在進行運算時,建議在第一個數據後加L,那麼運算的結果則表示是long類型的结果.
        System.out.println(f);//300億
```

#### 小數類型

#### double

> double類型在内存中占用8個字元,可以儲存很大很大的數據...

- ##### 小數直接量默認類型就是double類型,也可以在直接量後加D.

- **若想表示float需要在直接量後加F或f**

- ##### double類型的數據在進行運算時,可能存在誤差

```java
package day02;


import java.math.BigDecimal;

/**
 * 小數類型 double 的使用演示類:
 */
public class DataTypeDemo02 {

    public static void main(String[] args) {
                  //3.14 是小數直接量  默認就是double類型
        double a = 3.14;

        double b = 3.0;
        double c = 2.9;
        System.out.println( b - c );//0.10000000000000009  小數運算時可能存在誤差

        double d = 6.0;
        double e = 4.9;
        System.out.println( d - e);//1.0999999999999996    小數運算時可能存在誤差

        double g = 6.0;
        double h = 1.9;
        System.out.println( g - h );//4.1                 小數運算時可能存在誤差
        float f = 5.9f;
        float i = 4.2f;
        System.out.println( f - i );//4.1

//        BigDecimal decimal1 = BigDecimal.valueOf(6.0);   //無誤差寫法
//        BigDecimal decimal2 = BigDecimal.valueOf(4.9);
//        System.out.println( decimal1.subtract(decimal2));

    }
}
```

#### 字元類型

#### char

> char類型在内存中占用2個字元,可以存單個字元的數據類型

##### 字元: 鍵盤上的字母/數字/漢字/特殊符號等........

##### Unicode: 統一字元碼,萬國碼,Unicode中劃分很多個子集,Java中的char類型,採用的最常用的子集(ASCII)碼表.

- ##### 一個字元本質就是一碼：表象是字元，本質上處理的碼（0~65535）

- ##### 字元類型的直接量,只能用單引號來儲存,且只能儲存一個字元,至少存一個.

- ##### Java提供了特殊符號,如果想要儲存Java提供的特殊符號的時候, 我們需要轉義,需要使用Java提供的轉譯符\

```java
 //char的使用
        char temp = 'A';//單引號儲存 只能存一個 至少存1個
        System.out.println(temp);//字元
        System.out.println((int)temp);//該字元對應的碼

        char t1 = '\'';//儲存特殊符號需要轉譯  \'
        System.out.println(t1);

        char t2 = '\\';//儲存一個\ 也需要轉譯 \\
        System.out.println(t2);
```

#### 布爾類型

#### boolean

> boolean在内存中占用1個字元,裡面只能存一個值   要麼是true(成立)   要麼false(不成立)

```java
        boolean a = true;
        System.out.println(a);
        boolean b = false;
        System.out.println(b);
```

#### 基本數據類型轉換

##### 基本數據類型從小到大: byte --- short --- int  ----long  ---- float  ---- double

- ##### 自動類型轉換(隱式轉換):將小類型 賦值給 大類型的過程

```java
    /** 自動類型轉換：將小類型 賦值給 大類型的過程
         */
        int a = 100;//並沒有發生類型轉換
        long b = a;//發生了自動類型轉換
        double c = b;//發生了自動類型轉換
```

- ##### 強製類型轉換(顯示轉換):將大的類型 賦值給 小類型的過程

  - ##### 強轉有風險,轉換需謹慎

```java
  /**強製類型轉換:將大的類型 賦值給 小類型的過程
         */
        long a1 = 2000000000L;//20億
        int b1 = (int)a1; //使用強轉語法,在需要強轉的變數前加上(寫要強轉的類型) 即可
        System.out.println(b1);//20億

        long a2 = 3000000000L;//30億
        int b2 = (int)a2; //使用強轉語法,在需要強轉的變數前加上(寫要強轉的類型) 即可
        System.out.println(b2);//溢出的數據  a2中的30億超過了轉換類型所容納的範圍

        double c1 = 3.14;
        int c2 = (int)c1;//將小數類型轉換為整數時,截斷刪除小數
        System.out.println(c2);//3
```

#### 運算規則

- ##### 整數直接量是可以直接賦值給 byte,short,char類型的,但是不能超過當前類型所容納的範圍。

- #####  byte,short,char這些類型,在進行運算時,係統會自動將其结果轉換為int類型。

- ##### 小類型與大類型進行運算時,係統會自動將其結過轉換為大類型。

```java
		 /**整數直接量是可以直接賦值給 byte,short,char類型的,但是不能超過當前類型所容纳的範圍。
         * byte: -128 ~ 127      char: 0 ~ 65535
         */
        byte b = 127;
        char c = 65535;
        /**byte,short,char這些類型,在進行運算時,係統會自動將其结果轉換為int類型。
         */
        byte b1 = 100;
        byte b2 = 20;
        byte b3 = (byte) (b1 + b2);
//        int b4 = b1 + b2;
        System.out.println(b3);
        
        char d = 'a';//97
        char e = 'a';//97
        char r = (char) (d + e);//d+e 本質上就是字元碼相加 強轉char 則是 將這個碼轉換成對應的字元。
        System.out.println(r);//字元
        /**小類型與大類型進行運算時,係統會自動將其結過轉換為大類型。
         */
        int a1 = 100;
        long a2 = 1000L;
//        int a3 = (int)(a1 + a2);
        long a3 = a1 + a2;
        System.out.println(a3);
```

### 運算符

- #### 數學運算符

  - #####  符號：  +    -     *     /      取餘  %

```java
   		  int a = 10;
        int b = 5;
        int c = a + b;
        System.out.println(c);//15
        System.out.println(a - b);//5
        System.out.println(a * b);//50
        System.out.println(a / b);//2
        System.out.println(a % b);//0      10 % 5就是取 10/5的餘數

        //取餘操作時,左邊數據小於右邊數據 餘數還是左邊數據 如果左邊數據等於右邊數據 餘數則 為 0
        System.out.println(1 % 3);//1
        System.out.println(2 % 3);//2
        System.out.println(3 % 3);//0
        System.out.println(8 % 2);//0
        
        //判斷一個數是否是奇偶數---
```

- #### 自增自減運算符

  > 作用於變數自身

  - ##### 自增：在變數自身基礎上增加1  ， 符號++

  - ##### 自減：在變數自身基礎上減少1  ,    符號 --

    - ##### 單元運算(單獨運算),只有一個變數參與運算,符號在前在後都一樣

    - ##### 參與運算(賦值也算運算),符號在前在後不ㄧ樣

      1. ##### 符號在前,先去執行符號對應(自增或自減)的操作,然後再處理其他運算

      2. ##### 符號在後,先去處理其他運算,處理完後再做符號對應的(自增或自減)的操作

```java
//單元運算(單獨運算),只有一個變數參與運算,符號在前在後都一樣
        int a = 5;
        ++a;
        System.out.println(a);//6
        --a;
        System.out.println(a);//5




/** 參與運算(賦值也算運算),符號在前在後不ㄧ樣
   * 1.符號在前,先去執行符號對應(自增或自減)的操作,然後再處理其他運算
   * 2.符號在後,先去處理其他運算,處理完後再做符號對應的(自增或自減)的操作
*/
       int a = 5;
       int b = 5;
       int c = --a;
       int d = b--;
       System.out.println(a);//4
       System.out.println(b);//4
       System.out.println(c);//4
       System.out.println(d);//5

       int a = 5;
       int b = 5;
       int c = a++;
       int d = ++b;
       System.out.println(a);//6
       System.out.println(b);//6
       System.out.println(c);//5
       System.out.println(d);//6

        //面試題：考察的是底層的自增或自減的賦值過程
        int a = 1;
        /** 符號在後：
         *          1)先將變數中的内容 賦值給 臨時變數        int temp = a;
         *          2)再將變數中内容進行自增                 a = a + 1;
         *          3)將臨時變數 temp 賦值給 a              a = temp
         */
        a = a++;
        System.out.println(a);//1

        int b = 1;
        /** 符號在前：
         *          1)先將變數中内容進行自增                 b =  b + 1;
         *          2)再將變數中的内容 賦值給 臨時變數        int temp = b;
         *          3)將臨時變數 temp 賦值給 b              b = temp
         */
        b = ++b;
        System.out.println(b);//2
		
		----------------
        int c = 1;
        System.out.println(c++); //1    符號在後 先取值用  再自增
        System.out.println(c);//2
        System.out.println(++c);//3     符號在前 先自增   再取值
```

- #### 關係運算符

##### 關係運算符符號:  大於 >     小於 <     大於等於>=    小於等於<=      等於==      不等於 !=

##### 關係運算符的運算结果一定都是boolean類型,要麼成立(true)   要麼不成立(false)

```java
int  a = 50;  int b = 40;
boolean r1 = a > b;
a 的數據 大於 b 的數據嗎?   --------> true
    
int c = 50; int d = 50;
boolean r2 = c >= d;
c 的數據 大於等於 d 的數據嗎?---------> true

int e = 100; int f = 99;
boolean r3 = e == ++f;   ---------> true

System.out.println(100 != 100); ----> false  
    ---------
      	int a = 50;
        int b = 40;
        boolean r = a > b;
        System.out.println(r);//true
        System.out.println(a <= b);// false
        System.out.println(10 < 10);//false
        System.out.println(10 == 10);//true
        System.out.println(5 != 4);//true
        System.out.println(a >= 50);//true
```

####  ● 邏輯運算符

> 邏輯運算符的返回值,都是boolean類型

- ##### Java中的邏輯運算符分為三種：

  - ##### 邏輯與(並且), 符號 &&

  ```java
  邏輯與(並且)		現象：在邏輯與的關係中,兩個或以上的條件,只要有一個條件不成立,其结果一定不成立
  				    見 false  即  false  ----- 一假俱假
  能畢業嗎?
      	條件1：課程都學完了嗎?   true   false	 false	 true	
      		並且
      	條件2: 考試都及格嗎?   false	true	 false	  true	
              
              		   结果：  false	  false	 false	 true
  ```

  - ##### 邏輯或(或者)，符號 ||

  ```java
  邏輯或(或者)    現象：在邏輯與的關係中,兩個或以上的條件,只要有一個條件成立,其结果一定成立
      		      見 true 即 true   ----------一真即真
  能結帳嗎?
      	條件1：微信錢夠嗎?	 false	  true		true	false
      		或者
      	條件2: 現金帶夠嗎?	  true	   false	 true	  false
              
                    结果：  true	    true 		true    false
      
  ```

  - ##### 邏輯非(取反),   符號 ！
  
  ```java
  邏輯非(取反)
      		    true: !true  非真即假
               结果： false
              false: !false 非假即真
               结果:  true   
  ```
  
  

```java
  /**邏輯運算符：
         */
        int a = 5;
        int b = 10;
        int c = 5;
   
        boolean r = a > b && b > c;//false && true ---在邏輯與(並且)的關係中,見false即false
        System.out.println(r);//false

        System.out.println(a > b || b > c);//false || true ---在邏輯或(或者)的關係中,見true即true ---打印true
        System.out.println(a == ++c && c > 5);//false && true ---在邏輯與(並且)的關係中,見false即false--打印false
        System.out.println(c == ++a && b == 10);//true && true   ----结果true
        System.out.println( !(c == a));//false


        /** 判斷年份是否為閏年。
         *  year 年份
         *      條件1: 年份能被 4 整除 並且(&&) 年份 不能被 100整除
         *        或者
         *      條件2: 年份 能被 400 整除
         */

     //Scanner  ---掃描器功能: 掃描控製台中 用戶輸入的數據並接收.
       Scanner s = new Scanner(System.in);//創建一個掃描器
       System.out.println("請輸入年份,Enter即可判斷是否是閏年");
       int year = s.nextInt();//使用掃描器接收顯示台中int的數據 並賦值給 year這個變數
                       //         條件1                    或      條件2
       boolean result = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
       System.out.println(result);
```



#### 短路邏輯

- ##### 短路與: 兩個或多個條件中,若前面的條件不成立,直接返回不成立结果! 後面代碼不執行.

- ##### 短路或: 兩個或多個條件中,若前面的條件成立,直接返回成立结果! 後面代碼不執行.

```java
短路與:
		
	  相親成功的兩個條件:
	  1.相親對象是女生   false 
         並且
      2.貌美如花     	true
          
           结果:     false

短路或:
	   相親成功的兩個條件:
	  1.長得好看  true
         或者
    2.勤儉持家  true
          
       结果:   true
 --------------------
                //短路現象:
        int a1 = 5;
        int b1 = 20;

        System.out.println( a1 > b1 && ++b1 > a1);//並且的關係中,前面條件false 則立刻返回false  	發生了短路與
        System.out.println(b1);//20

        System.out.println(a1 < b1 && ++b1 > a1);//true  沒有發生短路
        System.out.println(b1);//21

        System.out.println(++a1 < b1 || ++b1 >= 21);//true 或者的關係中,前面條件true 立刻返回true 發生了短路或
        System.out.println(b1);//21
          
```

- #### 擴展賦值運算符

  - ##### 賦值號   =     賦值的順序從右向左賦值

  - ##### 擴展賦值號:可以在變數自身基礎上進行運算並將结果賦值給變數自身.

    - ##### 符號:   +=       -=     *=    /=        %=

```java
        int a = 10;
        a += 10;    // 等價於 : a = a + 10;
        System.out.println(a);//20
        a -= 10;    //等價於 : a = a - 10;
        System.out.println(a);//10
        a *= 2;     //等價於 : a = a * 2;
        System.out.println(a);//20
        a /= 5;     //等價於 : a = a / 5;
        System.out.println(a);//4
        a %= 2;     //等價於 : a = a % 2;
        System.out.println(a);//0

        /**面試題:
         *  byte b = 5;
         *  b = b + 5;
         *  System.out.println(b);//10
         */
        byte b = 5;
//      b = b + 5; 編譯錯誤: 小類型 + 大類型  運算结果是 大類型
        System.out.println(b);
        b += 5;//使用擴展賦值運算符,係統會自動做強轉  ----> b = (byte)(b+5);
        System.out.println(b);//10
```

- #### 三元表達式

##### 三元表達式格式:  判斷的邏輯 ?  邏輯成立返回值1 :  邏輯不成立返回值2;

> ##### 接收三元表達式返回结果的值時,要具體看值1和值2的類型 來聲明對應類型變數接收.

```java
        int a = 20;
        int b = 30;
        //a 和 b 之間 返回最大值
        //三元表達式固定語法: 判斷的邏輯 ?  成立返回值1 :  不成立返回值2;  根據需要套格式使用.
        int max = b > a ? b : a;
        System.out.println(max);//30

        //a 和 b 之間 返回最小值
        int min = b < a ? b : a;
        System.out.println(min);//20

        int c = 8;
        //判斷c是否是偶數  是偶數用true 表示  不是 false
        boolean r = c % 2 == 0 ? true : false;
        System.out.println(r);//true
        //注意:接收三元表達式返回结果的值時,要具體看值1和值2的類型 來聲明對應類型變數接收.
        char r1 = c % 2 == 0 ? 'Y' : 'N';
        System.out.println(r1);//Y
```

- #### 字符串拼接符

  - ##### 字符是char類型 ,用單引號來儲存,且只能存一個,至少存一個.

  - ##### 字符串是String類型,用雙引號來儲存,可以儲存一串字符,一個不存也沒事.
    - ##### 使用+號時，若兩端數據都是數值類型,則進行運算操作！

    - ##### 使用+號時，若兩端有一方是字符串類型,則進行拼接操作！變成完整的字符串。

```java
 //字符串類型,可以儲存一串字符
        String name = "李呆呆";
        System.out.println(name);
        System.out.println("這位同學的名字叫做:" + name);

        System.out.println(10 + 10 + "" + 30);//2030
        System.out.println("" + 6 + 6 + 6);// 666
        System.out.println(10 + 10 + 30 + "");//50 
```

### 程序結構

> 以後任何的複雜的業務邏輯,都可以通過程序結構來實現.

#### 程序結構分為三種:

- ##### 順序結構:代碼逐語句執行,每句代碼都執行.

- ##### 分支結構:有條件的執行某個語句,並非每句代碼都執行.

- ##### 循環結構:有條件的循環執行某個語句,並非每句代碼都執行.

#### 分支結構

```java
例如:
	    購物滿500  打8折	-------條件:購物滿500    ----true ------>打8折    ----單路分支
      
      購物滿500  打8折 不滿打9折-條件:購物滿500  -----true ------>打8折    ----雙路分支
          									                -----false------>打9折			
```

- ##### 單路分支

  > 當對於一個條件判斷结果成立時,才能執行的某句代碼時使用.

```java
package day03;

/**
 * 單路分支的使用演示類:
 */
public class IfDemo {
    public static void main(String[] args) { //類中大門
        /**單路分支的語法演示:
         *  if(判斷的條件){
         *      //當判斷條件成立時執行的代碼區域
         *  }
         *執行過程:
         *        程序遇到if語句,先去判斷小括號中的條件是否成立.
         *        若成立,則執行花括號中代碼塊區域的代碼
         */
        //購物金額滿500  打 8折
        double price = 500;//聲明了一個double類型的變數 叫price 裝了 500
        if (price >= 500) { //如果金額 大於等於 500
            price *= 0.8;//金額打8折
            System.out.println("打完8折後,應付:" + price);
        }
        System.out.println("已付款:" + price);
    }
}

```

- ##### 雙路分支

> 當對一個判斷條件,成立時需要執行一段代碼 或 不成立需要執行一段代碼 時使用.

```java
package day03;

/**
 * 雙路分支的使用演示類:
 */
public class IfElseDemo {
    public static void main(String[] args) {
        /**雙路分支的語法:
         *  if(判斷的條件){
         *      //當判斷條件為true時 執行的代碼塊區域
         *  }else{  //否則
         *      //當判斷條件為false時 執行的代碼塊區域
         *  }
         *  執行過程:
         *         當程序執行到if語句時,判斷小括號中的條件
         *         若為true  執行true對應代碼塊區域
         *         若為false 執行false對應代碼塊區域
         */
        //購物金額滿500 打8折 不滿打9折
        double price = 489;
        if(price >= 500){//如果金額 大於等於 500
            price *= 0.8;//金額打8折
            System.out.println("打完8折後,應付:" + price);
        }else { //否則
            price *= 0.9;//金額打8折
            System.out.println("打完9折後,應付:" + price);
        }
        System.out.println("已付款:"+price);
    }
}

```

- ##### 多路分支

> 當對一個數據有多種判斷條件時,使用多路分支的語法.

```java
package day03;


import java.util.Scanner;

/**
 * 多路分支的使用演示類:
 */
public class IfElseIfDemo {
    public static void main(String[] args) {
        /** 多路分支的使用演示:
         *  if(判斷的條件1){
         *    條件1成立所執行的代碼塊區域
         *  }else if(判斷的條件2){
         *    條件2成立所執行的代碼塊區域
         *  }else if(判斷的條件3){
         *    條件3成立所對應的代碼塊區域
         *  }
         *  //後面逐語句執行...
         *執行過程:
         *       先判斷條件1的结果是否成立,   若為true則執行條件1對應的代碼塊,
         *     否則如果判斷條件2的结果是否成立,若為true則執行條件2對應的代碼塊,
         *     否則如果判斷條件3的结果是否成立,若為true則執行條件3對應的代碼塊,
         */
        //當對一個數據有多種判斷條件時,使用多路分支的語法.
        /**需求:通過用戶輸入的分數,來判斷用戶的成績等級.
         *  例如: score(分數)
         *  A. 如果 分數 大於等於 90            輸出優秀
         *  B. 如果 分數 小於90 並且大於等於80   輸出良好
         *  C. 如果 分數 小於80 並且大於等於70   輸出一般
         *  D. 如果 分數 小於70 並且大於等於60   輸出及格
         *  E. 如果 分數 小於60                輸出不及格
         */
        Scanner s = new Scanner(System.in);//創建一個掃描器
        System.out.println("請輸入你的分數,Enter即可");
        int score = s.nextInt();//接收控製台中輸入的分數 存給 score變數
        if (score >= 90) { //A
            System.out.println("優秀");
        } else if (score >= 80) {//B
            System.out.println("良好");
        } else if (score >= 70) {//C
            System.out.println("一般");
        } else if (score >= 60) {//D
            System.out.println("及格");
        } else { //否則
            System.out.println("不及格");
        }
        /**  課堂練習： 通過控製台的方式 獲取用戶輸入的年齡 根據年齡判斷人生階段
         *      int age = ?;
         *      A. 如果    age  大於等於 0 並且小於 5    輸出幼年！
         *      B. 否則如果 age 大於等於 5  並且小於18   輸出青年！
         *      C. 否則如果 age 大於等於 18 並且小於 35  輸出成年！
         *      D. 否則如果 age 大於等於 35 並且小於 50  輸出中年！
         *      E. 否則如果 age 大於等於 50 並且小於 65  輸出中老年！
         *      F. 否則如果 age 大於等於 65 並且小於 150 輸出老年！
         *         否則               輸出年齡不合法！
         * */
        Scanner s = new Scanner(System.in);//創建一個掃描器
        System.out.println("請輸入你的年齡,Enter即可");
        int age = s.nextInt();//接收控製台中輸入的分數 存給 age變數
        if (age >= 0 && age < 5) {
            System.out.println("幼年");
        } else if (age >= 5 && age < 18) {
            System.out.println("青年");
        } else if (age >= 18 && age < 35) {
            System.out.println("成年");
        } else if (age >= 35 && age < 50) {
            System.out.println("中年");
        } else if (age >= 50 && age < 65) {
            System.out.println("中老年");
        } else if (age >= 65 && age < 150) {
            System.out.println("老年");
        } else { //否則
            System.out.println("年齡不合法");
        }
    }
}

```

#### 多路分支二:

#### switch結構

##### 適用性:  switch結構只能對數據進行判等的操作，支持 byte short int 這些整數類型的判斷，JDK1.8還增加支持String,枚舉判斷是否相等.  不能進行邏輯判斷或關係判斷.，判等時效率優於 if...else if 的結構.

- ##### Switch...case是一種特殊分支結構，可以根據一個整數表達式的不同取值，從不同的程序入口開始執行，常常用於實現多路結構.

- ##### 優點：效率高，結構清晰

- ##### 缺點：只能於整數操作（整數byte, short, int, char，字符串 String，枚舉）

##### break 關鍵字,退出至當前代碼塊的结束位置.

##### default 的使用,相當於 else的使用,如果代碼能執行到default 則表示上述case 都沒匹配上.

```java
  // switch 模擬電話客服的流程
        Scanner s = new Scanner(System.in);
        System.out.println("請輸入按鍵:1.中文服務2.英文服務0.人工服務");
        int user = s.nextInt();//接收用戶輸入的按鍵值
        switch (user){ //小括號放判斷的數據
            case 1: // 等價於 if(user == 1)
                System.out.println("中文服務開始了...");
                break;//退出當前switch結構的關鍵字
            case 2: //等價於 else if(user == 2)
                System.out.println("英文服務開始了...");
                break;//退出當前switch結構的關鍵字
            case 0://等價於 else if(user == 0)
                System.out.println("人工服務開始了....");
                break;//退出當前switch結構的關鍵字
            default: //相當於否則語句  上述語句都沒匹配 則執行default
                System.out.println("輸入的指令不合法");
        }//switch 結構 结束的花括號
```

#### 循環結構

##### 循環: 字面意思指的是重複去做的某一件事情,在程序指的是代碼的循環.

##### 循環的三要素: 1.循環變數的初始化   2.基於循環變數的條件   3.循環變數的改變(朝著目標改變)

```java
跑三圈
							初始圈數為0
跑夠三圈了嗎?   不夠   跑一圈      圈數為1
跑夠三圈了嗎?   不夠   跑一圈      圈數為2
跑夠三圈了嗎?   不夠   跑一圈      圈數為3
跑夠三圈了嗎?   夠了  ..不跑了    
--------------------------------------------
    循環三要素:
			 1.  int count = 0;  //循環變數初始化 	(初始圈數)
			 2.   count < 3 ;    //基於循環變數的條件 (判斷圈數是否小於3)
			 3.   count++;      //循環變數的改變    (圈數自增)

```

- ##### while

> 特點:先判斷循環條件,再决定是否執行循環體,有可能一次都不執行.

```java
package day04;

/**
 * while 循環的演示類:
 */
public class WhileDemo {
    public static void main(String[] args) {
        /**while 語法演示:
         *  while(循環條件){
         *      循環條件成立時 執行的代碼塊區域
         *  }
         *  ...代碼
         * 執行過程:
         *        執行while先去判斷while小括號中的條件是否成立
         *        若成立 則執行一次循環體 然後再判斷 while小括號中的條件是否成立
         *        若成立 則執行一次循環體 然後再判斷 while小括號中的條件是否成立
         *        ...
         *        直至不成立  代碼繼續向下執行
         */
        //行動是成功的階梯,大家都是最棒的!!!  x3

        //循環的三要素: 1.循環變數的初始化   2.基於循環變數的條件   3.循環變數的改變
        int count = 0;//初始為0
        while (count < 3) {//判斷count是否小於3
            System.out.println("行動是成功的階梯,大家都是最棒的!!!");//打印語句
            count++;//count自增1
        }
        System.out.println("循環结束");
    }
}

```

- ##### dowhile

> 特點:會先去執行一次循環體,再判斷循環條件,至少執行一次循環體.

```java
package day04;

/**
 * do while 的語法演示類:
 */
public class DoWhileDemo {
    public static void main(String[] args) {
        /** do while 語法演示
         *  do{
         *      循環體
         *  }while(循環條件);
         *
         *  執行過程:
         *      程序執行到do 先去執行一次循環體,再判斷while小括號中的條件
         *      若條件成立  則再次執行一次循環體,再判斷while小括號中的條件
         *      若條件成立  則再次執行一次循環體,再判斷while小括號中的條件
         *      ....
         *      直至條件不成立 代碼繼續向下執行
         */
        //同學們繼續加油！X3
        //循環的三要素: 1.循環變數的初始化   2.基於循環變數的條件   3.循環變數的改變
        int count = 0;
        do {
            System.out.println("同學們繼續加油！");
            count++;//循環變數改變
        } while (count < 3);
        System.out.println("循環结束..");
    }
}
```

##### while和dowhile的區别

##### 相同點：當已知循環條件,不明確循環次數時使用的循環

- ##### 區别：

  - ##### while：先判斷循環條件,再决定是否執行循環體,有可能一次都不執行.

  - ##### dowhile: 會先去執行一次循環體,再判斷循環條件,至少執行一次循環體.

#### 隨機數

##### Java中提供的一個功能,通過 Math.random();語法 返回一個 0 ~ 1區間的隨機小數 ,取不到1 最多0.9999....

```java
 /** 隨機數的使用
         */
        double ran1 = Math.random();//返回一個0 ~ 1區間的隨機小數 最多0.99999的數據
        System.out.println(ran1);

        double ran2 = Math.random() * 100;//返回一個0 ~ 100區間的隨機小數 最多99.99999的數據
        System.out.println(ran2);

        int ran3 = (int) (Math.random() * 100);//返回一個0 ~ 100區間的隨機整數 最多99的數據
        System.out.println(ran3);
        //自定義區間取值公式:   Math.random() *(最大值 - 最小值) + 最小值
        //90 ~ 100 之間的隨機數
        int ran4 = (int) (Math.random() * (100 - 90) + 90);
        System.out.println(ran4);
```

```java
package day04;
import java.util.Random; //1.導入一個隨機數
/** 
 * 隨機數 Random 的演示類：
 */
public class RandomDemo {
    public static void main(String[] args) {
        Random rand = new Random(); //2.新建一個隨機數對象，叫 rand

        //int num = rand.nextInt(); //返回一個int範圍(正負21個多億)内的隨機數
        //int num = rand.nextInt(5); //返回一個0～4的隨機數
        //int num = rand.nextInt(100); //返回一個0～99的隨機數
        /*
          31:最大值-最小值+1
          20:最小值
         */
        //int num = rand.nextInt(31)+20; //20～50
        //int num = rand.nextInt(51)+15; //15～65
        //int num = rand.nextInt(42)+22; //22～63
        int num = rand.nextInt(36)+10; //10～45
        System.out.println("生成的隨機數為:" + num);
    }
}
```



#### 猜大小案例

##### 1.0：程序運行後,產生一個隨機數0~100的值,用戶通過輸入方式 猜係統產生的數據是多少。

##### 2.0：如果用戶沒猜對,希望用戶一直猜,直到猜對為止。 -----需要用到dowhile    先猜一次 再决定是否繼續猜。

```java
  /**猜大小案例
         1.0：程序運行後,產生一個隨機數0~100的數據,用戶通過輸入方式 猜係統產生的數據是多少。
         如果猜對了則打印“猜對了” , 如果猜錯了打印猜錯了。

         2.0：如果用戶沒猜對,希望用戶一直猜,直到猜對為止，如果猜錯了提示猜大 或猜小 。 -----需要用到dowhile
         先猜一次 再决定是否繼續猜。    循環條件： 沒猜對就要一直猜   user != r
         */
        int r = (int) (Math.random() * 100);//產生一個隨機整數 0 ~ 99
        Scanner s = new Scanner(System.in);//創建一個掃描器
        int user;//變數能夠使用的範圍,取决於聲明變數時從上找離變數最近開始括號 與對應的结束花括號的區間位置使用。
        int count = 0;//紀錄次數
        do {
            System.out.println("請輸入要猜的數據範圍(0~99),Enter即可");
            user = s.nextInt();//接收用戶輸入猜的數據
            count++;
            if (user == r) { //如果用戶猜的數據等於係統產生的隨機數
                System.out.println("猜對了");
            } else if (user > r) {
                System.out.println("猜大了");
            } else {
                System.out.println("猜小了");
            }
        } while (user != r);//循環條件：用戶猜的不等於係統產生的數據

        //3.0 練習: 當猜對了以後  打印總共猜了多少次！  如果猜的次數  大於10  打印  笨蛋！
        //                  否則如果猜的次數 大於 5  打印 還行！
        //                  否則如果猜的次數 大於 3  打印 優秀！
        //                  否則           打印買彩票去吧！
        System.out.println("猜的次數:" + count);
        if (count > 10) {//如果猜的次數  大於10
            System.out.println("笨蛋");
        } else if (count > 5) {
            System.out.println("還行");
        }else if(count > 3){
            System.out.println("優秀");
        }else {
            System.out.println("買彩票去...");
        }


```

##### while的作業

#####  題目： 一個球從100米的高空墜下,每次彈起是原高度的一半。

- ##### 	問：1.總共彈起多少次  (最小的彈起高度 >= 0.01)

- #####              問：2.總共經過多少米

```java
/** while的作業：
         *  題目： 一個球從100米的高空墜下,每次彈起是原高度的一半。
         *        問： 1.總共彈起多少次  (最小的彈起高度 >= 0.01)
         *            2.總共經過多少米
         */
        double height = 100; //起始高度
        int count = 0;//用於紀錄彈起次數
        double distance = height;//用來紀錄總共經過的距離
        while (height / 2 >= 0.01) {//如果彈起高度 大於等於 0.01 才能表示能彈起
            height /= 2;//高度減半
            distance += height * 2;//累加起落距離
            count++;//自增彈起次數
        }
```

- ##### for(最常用)

> 當已知循環次數時,推薦使用for循環

```java
package day04;

/**
 * for循環的使用演示類：
 */
public class ForDemo {
    public static void main(String[] args) {
        /** for語法演示類：
         * 循環的三要素: ①循環變數的初始化   ②基於循環變數的條件   ③循環變數的改變
         *           ①      ②     ③
         *  for(int i = 0; i < 3 ; i++){
         *      //④循環體
         *  }
         * 執行過程：
         *         先執行 ①      ②滿足則執行    ④
         *         再執行 ③      ②滿足則執行    ④
         *         再執行 ③      ②滿足則執行    ④
         *         ..... 直至②不滿足,循環结束。
         */
        for (int i = 0; i < 3; i++) {
           System.out.println("今晚天氣好晴朗！！");
        }
        // continue;  關鍵字作用:代碼遇到continue 跳過當次循環,再次執行下一次循環
        for (int i = 1; i <= 10; i++) {
            if (i % 2 == 0) {
                System.out.println(i + ":是偶數");
                continue;//跳過當次循環
            }
            System.out.println(i + ":是奇數");
        }
      ㄑ
        // break;    關鍵字作用:代碼遇到break  退出當前循環.
        for (int i = 1; i <= 10; i++) {
            if (i > 5) {
                System.out.println("肚子痛,不能再跑了!!!");
                break;//退出當前循環
            }
            System.out.println("該同學跑了第:" + i + "圈了...");
        }
        System.out.println("終於可以歇歇了....");

    }
}

```

##### for小括號中的變數比較特殊,作用範圍只是當前for中可掃,其它地方視為看不到.

```java
  for (int i = 0; i < 3; i++) {
          
   }

  for (int i = 0; i < 3; i++) {//與上面for中的循環變數i 沒有衝突.
          
   }
```

- #### continue練習

  - ##### 題目:計算1 到 100之間 能被 3整除的所有數字之和.

    - ##### 在循環中判斷當前循環變數 是否能被3整除(是否是三的倍數) ,計算是3的倍數 累加和

```java
  		 int  sum = 0;
        for(int i = 1; i <= 100; i++){
            if(i % 3 != 0){
                continue;//跳過當次循環
            }
            sum += i;//累加1~100之間 3的倍數 和
        }
        System.out.println("累加1~100之間 3的倍數和:"+sum);//1683

```

- #### break練習

  - ##### 題目:使用循環統計1到100之間的數字和,當和大於等於2500時,循環終止,

    - ##### 打印統計和的數據是多少.

    - ##### 打印最後一次累加的數字是多少.

```java
         int sum = 0;//紀錄累加和
         int number = 0;//紀錄最後一次加的數字
         for (int i = 1; i <= 100; i++) {
         if (sum >= 2500) {
         break;//退出循環
         }
         number = i;//紀錄當前累加的數字
         sum += i;//累加和
         }
         System.out.println("總和:" + sum);
         System.out.println("最後一次累加的數字:" + number);
```



- #### for練習

  - ##### 題目:當運行程序後,隨機出10道0~100的加法題,然後讓用戶輸入答案,判斷用戶輸入的答案是否正確.

  - ##### 正確 打印正確,錯誤打印錯誤.

  - ##### 需求：答對一道題+10分    等10道題答完後 判斷成績等級。

  - ##### 提示：1.  出題      2.答題      3.判題
  
    - ##### 思考： 出一道題 會不會？     一道題實現了 再想10道題。

```java
運行現象如下: 
(1) 50 + 50 = ?
    請回答:
	100
    答對了
(2) 88 + 99 = ?
    請回答:
	187
    答對了
(3) ......
(10) 1 + 1 = ?
     請回答：
     3
     答錯了   
        -------------------------
  Scanner s = new Scanner(System.in);//創建一個掃描器
        for (int i = 1; i <= 10; i++) {
            int r1 = (int) (Math.random() * 100);//隨機數1
            int r2 = (int) (Math.random() * 100);//隨機數2
            System.out.println("(" + i + ") " + r1 + " + " + r2 + " = ?");
            System.out.println("請回答:");
            int userData = s.nextInt();//接收用戶輸入的數據
            if (userData == (r1 + r2)) {//判斷用戶的數據 與係統產生的隨機數和 是否一樣
                System.out.println("答對了");
            } else {
                System.out.println("答錯了");
            }
        }        
```

### 雙重for循環(for循環嵌套)

#### 外層for 用於控製輪數   也可以稱控製  行數

#### 内層for 用於控製次數    也可以稱控製 列數

```java
package day04;

/**
 * 雙重for循環的使用演示類:
 * 九九乘法表實現
 */
public class ForDemo02 {
    public static void main(String[] args) {

        for (int number = 1; number <= 9; number++) {//外層for循環   控製輪數
            for (int i = 1; i <= number; i++) {//内層for循環         控製次數  //tab鍵
                System.out.print(i + " * " + number + " = " + (i * number) + "\t");
            }
            System.out.println();//換行
        }

        //外層控製行  内層控製列
        for (int i = 1; i <= 5; i++) {//控製行
            for (int j = 1; j <= i; j++) {//控製列
                System.out.print("☆");
            }
            System.out.println();//換行
        }
    }
}

```

### 數組

##### 適用性: 數組可以儲存同一類型多個元素的集合.  可以理解為一個大容器,可以儲存同一類型的多個元素.

##### 數組是一種數據類型,引用數據類型.

- ##### 數組的聲明與初始化

- ##### 數組的訪問

- ##### 數組的遍歷

> ##### 當需要儲存多個同一類型的數據時,可以使用數組表示.

```java
生活中:   衣櫃      鞋櫃        橱櫃

int a; //聲明了一個int類型的變數  名為a    ---------------裡面只能儲存一個整數數據

int[] array;//聲明了一個int類型的數組 數組名為array ----裡面可以存多個整數數據,存多少取决於初始化空間

double[] arr1;//聲明了一個double類型的數組數組名為arr1--裡面可以存多個小數數據,存多少取决於初始化空間
-----
    package day05;

/**
 * 數組使用演示類:
 */
public class ArrayDemo {
    public static void main(String[] args) {
        //數組的聲明
        int[] arr;//聲明了一個int類型的數組  數組名為array
        //數組的初始化
        //静態初始化:當聲明數組時,已知數組的具體數據時使用.
        int[] a = {10, 20, 30};
        //動態初始化:當聲明數組時,已知儲存的數據個數時使用.
        int[] b = new int[3];//聲明了一個int類型的數組 名為b 為b這個數組開闢了3塊空間
        //數組的訪問:通過下標來訪問數組中每個元素,第一個元素下標0 依次類推 第二元素下標1  ......
        b[0] = 300;//訪問b數組下標0這塊空間  並賦值 300
        b[1] = 200;//訪問b數組下標1這塊空間  並賦值 200
        b[2] = 100;//訪問b數組下標2這塊空間  並賦值 100
//      b[3] = 999; ArrayIndexOutOfBoundsException:數組下標訪問越界異常
        System.out.println(b[0]);//300
        System.out.println(b[1]);//200
        System.out.println(b[2]);//100
        //數組的遍歷 :依次訪問數組中每個元素的過程 稱之為遍歷
        int[] array = {10, 20, 30, 40, 50, 60};
        //數組名.length  拿到數組的長度  第一個元素按 1 開始算
        //數組下標 第一個元素從0開始計算
        //所以遍歷數組時的循環條件一定是 < 數組長度
        //i --> index 下標.
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
            System.out.println(array[0]);
            System.out.println(array[1]);
            System.out.println(array[2]);
            System.out.println(array[3]);
            System.out.println(array[4]);
            System.out.println(array[5]);
      
      
        /** 題目: 假設沒有以下數組arr1，為arr1數組中每個元素累加上10
         *       最後arr1中的數據為 20，30，40，50，60
         */
        int[] arr1 = {10,20,30,40,50};

        for (int i=0;i< arr1.length;i++){
            arr1[i]+=10;
            System.out.println(arr1[i]);
        }

        /** 題目: 編寫一段程序，打印求出最大值，求arr2數組中最大值
         *  思路: 先聲明一個變數 int max;
         *       假設數組中第一個元素是最大值 max = arr2[0];
         *       循環遍歷 依次拿數組中每個元素與 max 作比較，
         *       如果 max 小於 當前遍歷到的數據 則將 當前數據 賦值給 max
         *       循環結束 max 存的就是最大值
         *       並打印 最大值 在當前數組中的下標值。
         */

        int[] arr2 ={300,1000,500,400,60};
        int max=arr2[0];
        int index =0;
        for (int i =0; i < arr2.length;i++){
            if (arr2[i]>max){
                max=arr2[i];
                index =i;
            }
        }
        System.out.println("最大值為: "+ max + "，對應的下標值為: "+ index);


        /** 題目: 通過運行程序後，在控制台界面依次輸入10名同學成績，存到一個數組中. 數組名 scores
         *    例如:  請輸入第 1名同學的成績 : 100
         *          請輸入第 2名同學的成績 : 90
         *          請輸入第 3名同學的成績 : 90
         *                ....
         *          請輸入第 10名同學的成績 : 60
         *          輸入完畢...
         */

        Scanner s = new Scanner(System.in);
        int[] scores=new int[10];

        for (int i=0;i < scores.length; i++){
            System.out.println("請輸入第" + (i+1) + "位同學成績:");
            int score = s.nextInt();
            scores[i]=score;
        }
        System.out.println("輸入完畢...");
       
        for(int i=0;i < scores.length; i++){
            System.out.println("第"+ (i+1) +"位同學成績為:"+ scores[i]);
        }
    }
}
```

### 方法

> ##### 方法表示的是功能(工具)

#### 適用性: 在程序中,當有一段邏輯表示是功能,希望能夠一次定義多次使用,實現代碼複用,以及解决代碼冗余問題時使用.(可以模塊化區分功能,方便查找以及解决相關問題)

- ##### 方法的語法:[訪問修飾符]  返回值類型  方法名([形式参數]){    方法體   }

- ##### 訪問修飾符:控製代碼的可掃範圍

- ##### 返回值類型：如果方法沒有返回值,用void來表示該位置即可。單獨使用return;則表示 退出方法。

  - ##### 			   如果方法有返回值,寫上該方法所返回的數據類型即可,且在方法结束花括號之前要寫return語句

    - ##### 	     return  返回具體的數據。 (退出方法並返回數據)   

- ##### 方法名：     遵循小駝峰命名法

- ##### 形式参數：定義形式参數 相當於占一個位置,具體當前参數的數據是多少,由調用者來决定。

  - ##### 			形式参數格式：  數據類型  變數名

- ##### 方法體：   存放功能代碼的區域。

##### 方法的分類：

- ##### 無参無返回值方法

  > 只是僅僅為了封裝一段重複的業務邏輯代碼時,沒有其他需求.可以寫無参無返回值方法

```java
package day05;

/**
 * 無参無返回方法的使用演示類：
 */
public class MethodDemo {
    public static void main(String[] args) {
        //多次定義  多次使用
        //首先重複...一旦需求發生修改,全都要變!
//        System.out.println("啪！一個右鞭腿");
//        System.out.println("啪！一個左刺拳");
//        System.out.println("啪! 一個過肩摔");
//        System.out.println("年輕人 好自為之");
//
//        System.out.println("啪！一個右鞭腿");
//        System.out.println("啪！一個左刺拳");
//        System.out.println("啪! 一個過肩摔");
//        System.out.println("年輕人 好自為之");
//
//        System.out.println("啪！一個右鞭腿");
//        System.out.println("啪！一個左刺拳");
//        System.out.println("啪! 一個過肩摔");
//        System.out.println("年輕人 好自為之");
//
//        System.out.println("啪！一個右鞭腿");
//        System.out.println("啪！一個左刺拳");
//        System.out.println("啪! 一個過肩摔");
//        System.out.println("年輕人 好自為之");
        attack();//調用attack方法
        attack();//調用attack方法
        attack();//調用attack方法
    }
    //方法語法: 返回值類型  方法名(){    方法體   }
    //無参數無返回值方法:只是僅僅為了封裝一段重複的業務邏輯代碼時,沒有其他需求.
    //好處: 一次定義 多次使用   需求發生改變  修改一次即可.
    //static 只是為了能夠在main中調用,不是方法必要語法.
    static void attack() {//自定義方法 如果不調用 是不會被執行的!
        System.out.println("啪！一個右鞭腿");
        System.out.println("啪！一個左刺拳");
        System.out.println("啪! 一個過肩摔");
        System.out.println("年輕人 好自為之");
        System.out.println("接~~化~~發");
    }
}
```

- ##### 有参無返回值方法

  > 當方法中定義邏輯時,有些數據無法確定下來,那麼我們可以將這個數據作為形式参數,變成有参數方法

```java
package day05;

/**
 * 有参數無返回值方法的使用
 */
public class MethodDemo02 {
    public static void main(String[] args) {
        int[] arr1 = {1,2,3,4,5,6,7};
        printArray(arr1);//調用方法傳入的是實際参數
//        for (int i = 0; i < arr1.length; i++){
//            System.out.print(arr1[i]+"\t");
//        }
        int[] arr2 = {5,6,7,8,9,10};
        printArray(arr2);//調用方法傳入實際参數
//        for (int i = 0; i < arr2.length; i++){
//            System.out.print(arr2[i]+"\t");
//        }
        int[] arr3 = {40,50,60,70,80};
        printArray(arr3);//傳實際参數時,要跟方法的定義的形式参數格式匹配.
//        for (int i = 0; i < arr3.length; i++){
//            System.out.print(arr3[i]+"\t");
//        }
        sayHi("呆呆",33);//傳入實際参數
    }
    /** 打印數組中數據的功能.
     *  當方法中定義邏輯時,有些數據無法確定下來,那麼我們可以將這個數據 作為形式参數
     *  形式参數的好處:1.可以將方法的内部邏輯定義完整 2.参數内容具體是什麼 由使用功能的人來决定
     *  形式参數格式：  數據類型  變數名
     *  有参數無返回的方法
     */
    static void printArray(int[] arr){
        for (int i = 0; i < arr.length; i++){
            System.out.print(arr[i]+"\t");
        }
        System.out.println();
    }
	    /**
     * 問好的 功能   :功能就是可以被很多地方去靈活使用
     * sayHi
     */
    static void sayHi(String name, int age) {//形式参數
        System.out.println(name + "同學你好!,我的年齡是:" + age);
    }
}

```

- ##### 無参有返回值方法

> 當方法被調用時,需要返回給調用者一個數據時使用.

```java
package day05;

/**
 * 無参有返回值的方法使用演示類:
 */
public class MethodDemo03 {
    public static void main(String[] args) {
        double pi = getPI();//調用有返回值方法 並接收的使用
        System.out.println(pi);
        System.out.println(getPI());//打印輸出並調用方法返回的值
        double ran = Math.random();
        System.out.println(ran);
    }
    /**
     * 需求: 寫一個功能方法,當該功能被調用時,返回一個pi(3.1415926)值
     * getPI
     */
    //
    static double getPI() {
//        double pi = 3.1415926;
        //return表示退出方法並返回的意思
        return 3.1415926;
    }  //如果方法寫了有返回值類型的方法,那麼在方法结束之前 要寫 return 退出返回 並寫上具體返回的數據.


}

```

- ##### 有参有返回值方法

```java
package day05;

/**
 * 有参有返回值的方法使用演示類:
 * 方法的重載.
 */
public class MethodDemo04 {
    public static void main(String[] args) {
        int result = sum(10, 20);
        System.out.println(result);//30
        double r1 = sum(1.5, 3.7);
        System.out.println(r1);
        int r2 = sum(40, 20, 10);
        System.out.println(r2);
        //println 打印的功能也實現了重載.
        System.out.println(10);
        System.out.println(1.1);
        System.out.println('A');
        System.out.println("ABC123");
        System.out.println(true);
    }
    //重載定義: 當多個方法表示功能是一致時,可以用一個方法名稱來統稱.
    //重載條件: 多個方法之間参數個數 或 参數類型不同 才可以構建重載的語法!
    //重載好處: 讓定義者不需要想不同的方法名 ,讓調用者不需要區分,直接根據需要傳遞實際参數使用,程序會自動區分
    /**
     * 需求: 能寫一個用於計算和的功,通過外部傳入的兩個整數數據,並返回運算结果.
     * <p>
     * sum ----方法名
     */
    static int sum(int a, int b) { //有参數有返回值的方法
        return a + b;//返回a + b 的和
    }
    /**
     * 需求: 能寫一個用於計算和的功,通過外部傳入的三個整數數據,並返回運算结果.
     * <p>
     * sum1  ----方法名
     */
    static int sum(int a, int b, int c) { //有参數有返回值的方法
        return a + b + c;//返回a + b + c的和
    }
    /**
     * 需求: 能寫一個用於計算和的功,通過外部傳入的兩個小數數據,並返回運算结果.
     * <p>
     * sum2  ----方法名
     */
    static double sum(double a, double b) {
        return a + b;//返回a + b 的和
    }

}

```

### 重載

- 重載定義: 當多個方法表示功能是一致時,可以用一個方法名稱來統稱.
- 重載條件: 多個方法之間参數個數 或 参數類型不同 才可以構建重載的語法!
- 重載好處: 讓定義者不需要想不同的方法名 ,讓調用者不需要區分,直接根據需要傳遞實際参數使用,程序會自動區分

```java
package day05;

/**
 * 有参有返回值的方法使用演示類:
 * 方法的重載.
 */
public class MethodDemo04 {
    public static void main(String[] args) {
        int result = sum(10, 20);
        System.out.println(result);//30
        double r1 = sum(1.5, 3.7);
        System.out.println(r1);
        int r2 = sum(40, 20, 10);
        System.out.println(r2);
        //println 打印的功能也實現了重載.
        System.out.println(10);
        System.out.println(1.1);
        System.out.println('A');
        System.out.println("ABC123");
        System.out.println(true);
    }
    //重載定義: 當多個方法表示功能是一致時,可以用一個方法名稱來統稱.
    //重載條件: 多個方法之間参數個數 或 参數類型不同 才可以構建重載的語法!
    //重載好處: 讓定義者不需要想不同的方法名 ,讓調用者不需要區分,直接根據需要傳遞實際参數使用,程序會自動區分
    /**
     * 需求: 能寫一個用於計算和的功,通過外部傳入的兩個整數數據,並返回運算结果.
     * <p>
     * sum ----方法名
     */
    static int sum(int a, int b) { //有参數有返回值的方法
        return a + b;//返回a + b 的和
    }
    /**
     * 需求: 能寫一個用於計算和的功,通過外部傳入的三個整數數據,並返回運算结果.
     * <p>
     * sum1  ----方法名
     */
    static int sum(int a, int b, int c) { //有参數有返回值的方法
        return a + b + c;//返回a + b + c的和
    }
    /**
     * 需求: 能寫一個用於計算和的功,通過外部傳入的兩個小數數據,並返回運算结果.
     * <p>
     * sum2  ----方法名
     */
    static double sum(double a, double b) {
        return a + b;//返回a + b 的和
    }

}
```

#### 方法的強化:

```java
public static void main(String[] args){ 
int[] arr2 = {300, 1000, 400, 6000, 70};
//        int max = arr2[0];//假設數組中第一個元素是最大值
//        for (int i = 0; i < arr2.length; i++) {
//            if (max < arr2[i]) { // 如果max中的數據 小於 當前遍歷到的數據
//                max = arr2[i];//將當前遍歷到的數據 賦值給 max變數
//            }
//        }
        int[] arr3 = {1000,10000,40000,400,500};
//        int max1 = arr3[0];//假設數組中第一個元素是最大值
//        for (int i = 0; i < arr3.length; i++) {
//            if (max1 < arr3[i]) { // 如果max中的數據 小於 當前遍歷到的數據
//                max1 = arr3[i];//將當前遍歷到的數據 賦值給 max變數
//            }
//        }
//        System.out.println("數組中最大值是:" + max1 );
        int[] arr4 = {70,40,20,80,9};
//        int max2 = arr4[0];//假設數組中第一個元素是最大值
//        for (int i = 0; i < arr4.length; i++) {
//            if (max2 < arr4[i]) { // 如果max中的數據 小於 當前遍歷到的數據
//                max2 = arr4[i];//將當前遍歷到的數據 賦值給 max變數
//            }
//        }
//        System.out.println("數組中最大值是:" + max2);
        //需求,根據上述代碼,發現重複冗余的求取最大值功能邏輯重複,定義方法來完成上述功能的修改
        //方法名:  getArrayMax
        System.out.println( getArrayMax(arr2) );//打印輸出 調用getArrayMax傳入arr2數組中的最大值
        System.out.println( getArrayMax(arr3) );
        System.out.println( getArrayMax(arr4) );
    }
   static int getArrayMax(int[] arr){ //有参數 有返回值方法
        int max = arr[0];//假設數組中第一個元素是最大值
        for (int i = 0; i < arr.length; i++) {
            if (max < arr[i]) { // 如果max中的數據 小於 當前遍歷到的數據
                max = arr[i];//將當前遍歷到的數據 賦值給 max變數
            }
        }
        return max;
    }
```

### 關於方法的作業:

- ##### 簡單題目

  - ##### 需求:寫一個功能,根據外部傳入的兩個整數數據,以及一個操作數char值來實現運算並返回结果.

  - ##### 例如:   調用方法:    operation(10,20,'+')   那麼方法返回的结果則是30

  - ##### 操作數就是char類型, 分别有'+'   '-'   '*'   '/'  實現四則運算.   if(操作數 == '+') {  返回相加结果}


```java
    static int operation(int a, int b, char o) {
        if (o == '+') {
            return a + b;
        } else if (o == '-') {
            return a - b;
        } else if (o == '*') {
            return a * b;
        } else if (o == '/') {
            return a / b;
        } else { //否則
            System.out.println("輸入的操作數不合法,return -1");
            return -1;
        }
    }
```

- ##### 困難題目:

  - ##### 需求:有以下數組 array, 通過實現一個反序功能,可以將該數組的内容實現反序.

  - ##### int[] array = { 1 ,2 ,3 ,4, 5, 6 ,7}

  - ##### 例如: 調用方法: reversalArray( array)   那麼方法執行完以後

  - ##### 遍歷array數組中的數據 則  為 7  6  5  4 3 2 1 

  - ##### 數組中最後一個元素下標     數組名.length - 1  

```java
  static void reversalArray(int[] arr) {
        for (int i = 0; i < arr.length / 2; i++) {
            int temp = arr[i];
            arr[i] = arr[arr.length - 1 - i];
            arr[arr.length - 1 - i] = temp;
        }
    }
```

# FOUNDATION02

### 面向對象

#### OOA: 面向對象的分析

#### OOD: 面向對象的設計

#### OOP: 面向對象編程(重點)

#### 面向對象直接决定入職速度和薪資水平。

#### 面向對象可以寫出高質量代碼

- ##### 高質量代碼：複用性要好！擴展性要好！維護性要好！移植性要好！健壯性要好！效率要好！可讀性要好！

#### 學完面向對象3個狀態：

1. ##### 聽不懂我在講什麼  -------落課  

2. ##### 暈乎乎的,能理解啥意思 -----     正常

3. ##### 大概聽懂了,但是讓設計設計不出來  -----優秀

------------

### 類和對象

- #### 類：抽象的不具體的,通常表示一類事物的統稱。      類在程序中表示模板

- #### 對象：具體的,真實存在(能看到或摸到的)。         對象在程序中指的是内存中產生的實例

#### 面向對象的三大特徵

##### 分析項目中的對象有哪些？

- ##### 一個戰艦,一堆深水炸彈,一堆偵察潛艇(銀色的),一堆魚雷潛艇(金黄色),一堆水雷潛艇(軍綠色),一堆水雷,魚雷

#### ObserverSubmarine(偵察潛艇)

- #### OS1     -------------------- x  ,   y   , width  , height  , speed

- #### OS2     -------------------- x  ,   y   , width  , height  , speed

- #### OS3     -------------------- x  ,   y   , width  , height  , speed

- #### OS4     -------------------- x  ,   y   , width  , height  , speed

......

- #### OS100     -----------------x  ,   y   , width  , height  , speed

#### 如果按上述代碼,100個對象,就會有100份相同的數據,數據冗余！重複！

#### 解决使用類來解决！

####    類								    對象

#### 月餅模具    批量產生     月餅對象

- #### 封裝

  ##### 類封裝的定義：將一類别下的多個對象之間共有的數據 和 行為 提取到一個類中當作模板使用。
  - ##### 如何創建類

    - ##### 類中放當前類别下所有對象共有的數據(屬性)   ---------變數

    - ##### 類中放當前類别下所有對象共有的行為(功能)   ---------方法

  ```java
  class Person{ //人的模板類
      //共有數據
      String name;//姓名 
      int age;//年齡
      char sex;//性别
      
      //共有行為
      void  eat(){  } //吃
      void sleep(){  }//睡
      void play(){   }//玩
  }
  class  Car{//車的模板類
      //共有數據
      String color;//顏色
      double price;//價格
      String type;//型號
      //共有行為
      void run(){  }//跑
      void stop(){  }//停
      void back(){ }//倒退  
  }
  
  class ObserverSubmarine{//偵察潛艇類
      //共有的數據
      int x;//x坐標
      int y;//y坐標
      int width;//寬
      int height;//高
      int speed;//速度
      
      //共有的行為
      void step(){ //移動的行為
          
      }
      
  }
  ```

  ##### 變數作用域分類：

  1. ##### 全局變數(成員變數):指的是在類中聲明的變數,稱之為全局變數,作用域在整個類中。

  2. ##### 局部變數:指的是在方法中聲明的變數，稱之為局部變數,作用域在聲明的方法中。

  ```java
  package oo.day01;
  
  /**
   * 學生模板類：
   * 放所有學生對象共有的數據 和行為的類.
   * 模板類 不需要添加main功能！
   */
  public class Student {
      //共有的數據     全局變數：在整個類中可使用
      String name;//姓名
      int age;//年齡
      int stuID;//學號
  
      //共有的行為
      void study() { //學習的方法
          int b = 1;//局部變數：只能在當前聲明位置的方法中使用
          System.out.println(name + "在學習！");
      }
      
      void sayHi() {//打招呼的方法
          int b = 1;
          System.out.println("大家好,我叫:" + name + ",今年:" + age + "歲了！,我的學號是:" + stuID);
      }
  }
  
  ```

  - ##### 如何創建對象

  ```java
數據類型  對象名     創建對象的語法
  Scanner  s 		= new Scanner();//創建一個掃描器對象
  
  Student zs 		= new Student();//創建一個學生類對象 並將對象賦值給zs這個變數
  Student ls 		= new Student();//創建一個學生類對象 並將對象賦值給ls這個變數
  Student ww 		= new Student();//創建一個學生類對象 並將對象賦值給ww這個變數
  ```
  
  - ##### 如何訪問對象
  
  ```java
  package oo.day01;
  
  /**
   * 創建對象,訪問對象的使用演示類
   */
  public class StudentDemo {
      public static void main(String[] args) {
          //創建學生類對象  先聲明可以裝學生對象的類型
          Student zs = new Student();//創建一個學生類對象 並將對象賦值給 zs這個變數
          //1. 創建對象時,對象中有什麼内容,取决於當前模板類。
          //2. zs這個變數能打點調用出什麼内容,也取决於模板類。
          //3. 編譯期間調什麼内容取决於模板,但是運行時具體數據的内容由對象來决定！
          zs.name = "張三";
          zs.age = 35;
          zs.stuID = 1001;
          zs.study();
          zs.sayHi();
  //        System.out.println(zs.name );
  //        System.out.println(zs.age );
  //        System.out.println(zs.stuID );
          Student ls = new Student();//創建一個學生類對象 並將對象賦值給 ls這個變數
          ls.name = "李四";
          ls.age = 28;
          ls.stuID = 1002;
          ls.study();
          ls.sayHi();
      }
  }
  ```
  
  ### 項目搭建
  
  ##### 項目需求：
  
  ```java
  1.識别對象
    	   戰艦類,深水炸彈類,偵察潛艇類,魚雷潛艇類,水雷潛艇類，魚雷類,水雷類
  2.分配職責
         戰艦(玩家):按下空格發生深水炸彈
         深水炸彈： 可攻擊三種潛艇,打到:
  				        1.如果炸彈打到潛艇,炸彈和潛艇消失
                  2.打到偵察潛艇或魚雷潛艇,加分
                  3.打到水雷潛艇加命
         魚雷潛艇： 發射魚雷,攻擊戰艦 若打到：
                  1.魚雷對象消失
                  2.戰艦扣1命
         水雷潛艇： 發射水雷,攻擊戰艦 若打到：
                  1.水雷對象消失
                  2.戰艦扣1命             
  3.建立交互... 
  ```
  
  - ##### 在src文件夾下創建一個項目包：  cn.tedu.submarine
  
  - ##### 選中包創建7個模板類：
  
  ```java
  戰艦類：Battleship
    數據：int x;  int y;  int width;  int height;  int speed;  int life;//生命值
    行為：void step(){ }	
  深水炸彈類：Bomb
    數據：int x;  int y;  int width;  int height;  int speed;  
    行為：void step(){ }	
  偵察潛艇類：ObserverSubmarine
    數據：int x;  int y;  int width;  int height;  int speed;  
    行為：void step(){ }	
  魚雷潛艇類：TorpedoSubmarine
    數據：int x;  int y;  int width;  int height;  int speed;  
    行為：void step(){ }	
  水雷潛艇類：MineSubmarine
    數據：int x;  int y;  int width;  int height;  int speed;  
    行為：void step(){ }	
  水雷類：Mine
    數據：int x;  int y;  int width;  int height;  int speed;  
    行為：void step(){ }	
  魚雷類：Torpede
    數據：int x;  int y;  int width;  int height;  int speed;  
    行為：void step(){ }	
  ```
  
  ##### GameWorld類的結構：
  
  ```java
  package cn.tedu.submarine;
  
  /**
   * 遊戲運行(窗口)類
   */
  public class GameWorld {
      //普通全局變數
      Battleship ship;
      Bomb bomb;
      ObserverSubmarine os;
      TorpedoSubmarine ts;
      MineSubmarine ms;
      Mine m;
      Torpedo t;
      void action() {//普通方法
          System.out.println("action方法執行了...");
          ship = new Battleship(); //創建一個戰艦類對象並賦值給 ship變數
          bomb = new Bomb();//創建一個深水炸彈對象 並賦值給 bomb變數
          os = new ObserverSubmarine();//創建一個偵察潛艇對象 並賦值給 os變數
          ts = new TorpedoSubmarine();//創建一個魚雷潛艇對象 並賦值給 ts變數
          ms = new MineSubmarine();//創建一個水雷潛艇對象 並賦值給ms變數
          t = new Torpedo();//創建一個魚雷對象 並賦值給 t變數
          m = new Mine();//創建一個水雷對象 並賦值給m變數
      }
      public static void main(String[] args) {
          GameWorld gw = new GameWorld();
          gw.action();//通過對象打點調用action方法
      }
  }
  /**
   * 1.為什麼要將各類型的變數聲明的工作放在main外面?
   * 答：因為main是個方法,方法中聲明的變數只能在方法中使用,後期當前類會有很多方法需要用到各類型的變數
   * 所以,將各類型變數做成全局變數。
   * 2.為什麼要單獨做一個action方法,來進行創建對象的操作?
   * 答：因為main是個static修飾的方法,比較特殊 是無法直接訪問類中的普通成員(變數,普通方法),所以單獨
   * 做一個普通方法來進行創建對象的操作。
   * 3.為什麼要在main中傳創建GameWorld類對象再調用action方法？
   * 答：因為main是個static修飾的方法,比較特殊 是無法直接訪問類中的普通成員(變數,普通方法),所以我們
   * 可以通過創建類對象,通過對象來打點調用即可。
   */
  ```

- ### 内存圖

  - ##### 默認值 ：指的一個類型的變數只聲明沒賦值的情况下,都會有一個對應該類型的默認值。

    - ##### 基本數據類型：整數類型默認值：0    小數類型默認值: 0.0   boolean默認值:false

    - ##### 引用數據類型：數組, String ,自定義的類  -----默認值都是null

      - ##### 當使用null值打點訪問内容,運行時則報空引用異常：NullPointerException
  
  - ##### 基本數據類型變數存數據             引用數據類型變數存地址

  -----------

  ##### 内存運行時由JVM來劃分3塊區域：

  > 棧區,堆區,方法區

  - ##### 棧區：用來存放局部變數的區域,局部變數指的是方法中聲明的變數.

    > ##### 特點: 方法執行完,方法中聲明的變數也會隨之銷毀.

  - ##### 堆區：用來存放對象的區域,對象指的是通過new關鍵字創建的.

    > ##### 特點: 堆區的對象,若沒有被引用,則會變為内存垃圾

  - ##### 方法區:後續講static講。
  
##### GC(垃圾回收器)：會不定期檢查内存,並清理内存垃圾。
  - ##### 創建對象的内存圖

  - ##### 基本數據類型數組的内存圖
  
  - ##### 引用數據類型數組的内存圖

-----------------

#### 項目問題：在GameWorld類中的action方法中,創建每一個對象時,都要依次打點為當前對象賦值數據。同一類型多個對象需要賦值,那這個過程特别麻煩 冗余。

#### 解决:使用構造方法來解决。

### 構造方法

> ##### 構造方法又稱之為構造器

##### 適用性：在創建對象時,可以快速的為當前對象初始化賦值。

1. ##### 構造方法的語法：類名(){}         注意：構造方法沒有返回值那一說。

2. ##### 構造方法的本質作用：創建對象的必要語法！

   - ##### 現象1：如果一個類，沒有明確添加構造方法,係統會贈送一個默認的無参構造方法

   - ##### 現象2：如果一個類,添加了構造方法不管是有参還是無参,係統都不再贈送！

3. ##### 構造方法的特點：構造方法在類被創建對象時執行。

4. ##### 構造方法的重載：當滿足参數個數或者滿足参數類型不同時,即可構建重載。

```java
Sudent模板類中：
Student(String name1,int age1,int stuID1){ //學生模板類的有参構造方法
        this.name = name1;
        this.age = age1;
        this.stuID = stuID1;
    }
    Student(){ //無参構造方法   ---跟上面的有参構造方法 實現構造方法重載  参數個數不同

    }
-----------------------------------------------
StudentDemo測試：
//創建學生類對象  先聲明可以裝學生對象的類型
                        //1.創建學生類對象  2.調用學生類的無参構造方法
        Student zs = new Student("張三",35,1001);//創建一個學生類對象 並將對象賦值給 zs這個變數
        //1. 創建對象時,對象中有什麼内容,取决於當前模板類。
        //2. zs這個變數能打點調用出什麼内容,也取决於模板類。
        //3. 編譯期間調什麼内容取决於模板,但是運行時具體數據的内容由對象來决定！
        zs.study();
        zs.sayHi();
////        System.out.println(zs.name );
////        System.out.println(zs.age );
////        System.out.println(zs.stuID );
        Student ls = new Student("李四",28,1002);//創建一個學生類對象 並將對象賦值給 ls這個變數
//        ls.name = "李四";
//        ls.age = 28;
//        ls.stuID = 1002;
        ls.study();
        ls.sayHi();

        Student ww = new Student();
        ww.name = "";
```

#### this關鍵字

##### Java規定: 局部變數可以與類中成員變數命名一樣。使用時遵循就近原則。

##### 如果想要明確區分成員變數與局部變數時,我們使用this來表示訪問是類中的成員！

##### 編譯期：this表示當前類。  運行期：this表示當前對象.

##### 在方法中this指代的是就是調用方法的對象

```java
main{
    Student zs = new Student("張三",35,1001);
    zs.study();
    Student ls = new Student("李四",28,1002);
    ls.study();
      
}
zs.study(); ---------------在study方法執行時, 使用的關於this的數據 都是 zs這個對象的
ls.study(); ---------------在study方法執行時, 使用的關於this的數據 都是 ls這個對象的
```

#### 解决項目問題：為各類型去添加對應的構造方法,目的讓對象創建時不用依次打點調用賦值。

```java
戰艦類構造方法：
Battleship() {//戰艦類只會存在一個對象,且一開始戰艦的位置,大小,速度,生命值都可以確定
        x = 270;
        y = 124;
        width = 66;
        height = 26;
        speed = 20;
        life = 5;
    }
深水炸彈類構造方法：
     Bomb(int x,int y){//因為炸彈被創建時 x y 不確定,所以創建對象時决定當前對象所在的位置。
        this.x = x;
        this.y = y;
        width =  9;
        height = 12;
        speed = 3;
    }
偵察潛艇類構造方法：
      ObserverSubmarine() { //偵察潛艇類構造方法
        width = 63;
        height = 19;
        x = -width;
        y = (int) (Math.random() * (479 - height - 150) + 150);
        speed = (int) (Math.random() * (3 - 1) + 1);
    }
魚雷潛艇類構造方法：
     TorpedoSubmarine() { //魚雷潛艇類構造方法
        width = 64;
        height = 20;
        x = -width;
        y = (int) (Math.random() * (479 - height - 150) + 150);
        speed = (int) (Math.random() * (3 - 1) + 1);
    }
水雷潛艇類構造方法：
     MineSubmarine() { //水雷潛艇類構造方法
        width = 63;
        height = 19;
        x = -width;
        y = (int) (Math.random() * (479 - height - 150) + 150);
        speed = (int) (Math.random() * (3 - 1) + 1);
    }
水雷類構造方法：
     Mine(int x, int y) {
        this.x = x;
        this.y = y;
        width = 11;
        height = 11;
        speed = 2;
    }
魚雷類構造方法：
     Torpedo(int x, int y) {
        this.x = x;
        this.y = y;
        width = 5;
        height = 18;
        speed = 2;
    }

```

#### 問題：除了戰艦以外,其它類型的對象都會存在多個對象,如何儲存同一類型的多個對象？

#### 可以用數組來表示：

```java
 //普通全局變數
    Battleship ship = new Battleship();//創建一個戰艦對象 賦值給ship
    Bomb[] bomb; //聲明一個深水炸彈數組  數組名bomb
    ObserverSubmarine[] os;//聲明一個偵察潛艇數組  數組名os
    TorpedoSubmarine[] ts;//聲明一個魚雷潛艇數組  數組名ts
    MineSubmarine[] ms;//聲明一個水雷潛艇數組  數組名ms
    Mine[] m;//聲明一個水雷數組  數組名m
    Torpedo[] t;//聲明一個魚雷數組  數組名t
    void action() {//普通方法
        bomb = new Bomb[2];//創建一個深水炸彈數組對象開闢了兩塊空間
        bomb[0] = new Bomb(10,10);//為下標0空間創建一個炸彈對象
        bomb[1] = new Bomb(10,20);//為下標1空間創建一個炸彈對象
        os = new ObserverSubmarine[2];//創建一個偵察潛艇數組對象開闢了兩塊空間
        os[0] = new ObserverSubmarine();//為下標0空間創建一個偵察潛艇對象
        os[1] = new ObserverSubmarine();//為下標1空間創建一個偵察潛艇對象
        ts = new TorpedoSubmarine[2];//創建一個魚雷潛艇數組對象開闢了兩塊空間
        ts[0] = new TorpedoSubmarine();//為下標0空間創建一個魚雷潛艇對象
        ts[1] = new TorpedoSubmarine();//為下標1空間創建一個魚雷潛艇對象
        ms = new MineSubmarine[2];//創建一個水雷潛艇數組對象開闢了兩塊空間
        ms[0] = new MineSubmarine();//為下標0空間創建一個水雷潛艇對象
        ms[1] = new MineSubmarine();//為下標1空間創建一個水雷潛艇對象
        m = new Mine[2];//創建一個水雷數組對象開闢了兩塊空間
        m[0] = new Mine(20,30);//為下標0空間創建一個水雷對象
        m[1] = new Mine(20,40);//為下標1空間創建一個水雷對象
        t = new Torpedo[2];//創建一個魚雷數組對象開闢了兩塊空間
        t[0] = new Torpedo(30,50);//為下標0空間創建一個魚雷對象
        t[1] = new Torpedo(30,60);//為下標1空間創建一個魚雷對象
    }
```

##### 項目問題：當前7個模板類中,存在共性屬性和行為！代碼冗余。

##### 解决: 可以通過繼承來解决！

- #### 繼承

> 生活中有哪些繼承？繼承財產：錢不用自己賺,繼承過來也能花。
>
> ​								   繼承皇位：江山不用自己打,繼承過來也能坐。
>
> ​								   繼承工作：工作不用自己找,繼承過來也能干活。

- ##### 代碼中的繼承含義:繼承代碼不用自己寫,繼承過來也能用。		

  - ##### 繼承適用性:當多個模板類之間存在共性的屬性和行為時,且這些模板類在概念能達到 is a(是一種)的關係。

  - ##### 繼承關鍵字: 通過 extends 實現繼承關係      子類  extends  父類   ,繼承得來代表自己有。

  - ##### 父類(超類):放所有子類共有的屬性和行為。

  - ##### 子類(派生類):放自己特有的屬性和行為。

  - ##### 實現繼承後:子類可以訪問自己的内容,也可以訪問繼承得來的内容。

  - ##### 父類只能訪問自己的内容。

    - ##### 繼承特點：具有單一性,傳遞性

    - ##### 繼承缺點:  耦合度較高！(父類中的代碼如果一旦發生改變,可能會直接影響所有子類)

##### 泛化：從多個類之間分析並提取冗余的數據到父類的過程稱之為泛化。

```java
class Person { //人類  ----當作代表類：代表多個模板之間共有的數據和行為
    String name;
    int age;
    char sex;
    void eat(){}
}
class Student extends Person{//學生類
    //放該類别下所有對象共有數據
    int stuID;//特有
    //放該類别下所有對象共有行為
    void study(){}
}
class Teacher extends Person{//老師類
    //放該類别下所有對象共有數據
    double salary;//特有
     //放該類别下所有對象共有行為
    void teach(){   }
}
class Doctor extends Person{//醫生類
    int level;//特有職級
    //行為
    void cut(){  }
}
```

##### 繼承的傳遞性:

```java
class 爺爺類{
    傳家寶(){ }
}
class 兒子類 extends 爺爺類{
    傳家寶(){ }
}
class 孫子類 extends 兒子類{
    傳家寶(){ }
}
```

#### 項目中的模板優化:

##### 將當前項目中7個模板類之間存在共有的屬性和行為提取到SeaObject這個父類中實現複用,7個模板類分别繼承SeaObject。

```java
package cn.tedu.submarine;

/**
 * 海洋對象類:
 *          7個模板類的父類,存放7個模板類之間共有的屬性和行為
 */
public class SeaObject {
    //子類共有數據
    int x;
    int y;
    int width;
    int height;
    int speed;

    //子類共有行為
    void step() {
    }
}

```

#### Super關鍵字

##### Java規定,構造方法不可以繼承。

1. ##### 如果實現了繼承,在創建子類對象時,子類的構造方法會先執行父類的構造方法,然後再執行本類的構造方法的内容. 如果沒有明確為父類提供構造方法,子類則執行是父類中默認無参構造方法。

   > 默認有一個super();   表示的是調用父類的無参構造方法

   ```java
   package oo.day02;
   
   /**
    * super關鍵字的使用演示類
    */
   public class SuperDemo {
       public static void main(String[] args) {
           Boo b = new Boo();//創建一個Boo類對象。
       }
   }
   
   class Aoo{ //父類
       Aoo(){
           System.out.println("父類的構造方法執行了...");
       }
   }
   class Boo extends Aoo{ //子類
       Boo(){
           super();//默認調用父類的無参構造方法   super代表超類(父類)
       }
   }
   ```

2. ##### 若父類中寫了有参數的構造方法,而沒有寫無参數構造方法,那麼子類實現繼承時,子類則會報錯,需要在子類的構造方法中明確要寫上super()表示調用父類的構造方法,根據父類構造方法的参數傳参即可。

```java
package oo.day02;

/**
 * super關鍵字的使用演示類
 */
public class SuperDemo {
    public static void main(String[] args) {
        Boo b = new Boo();//創建一個Boo類對象。
    }
}

class Aoo{ //父類
    Aoo(int a){ //有参數的構造方法
       
    }
}
class Boo extends Aoo{ //子類
    Boo(){
        super(1);//如果父類中提供了有参構造方法,那麼子類構造方法中需要明確使用父類有参構造方法.
    }
}
```

##### super  代表是父類    	this 代表是當前類

##### super.成員變數    -----------------訪問的則是父類的成員變數  (應用率不高)

##### super.方法		   ------------------訪問的則是父類的方法

##### super();			   -------------------訪問的是父類的構造方法.

##### 問題:當前偵察潛艇類,魚雷潛艇類,水雷潛艇類中構造方法冗余重複

##### 解决:在創建子類對象時,一定會先執行父類的構造方法,那麼完全可以將這3個潛艇類構造方法冗余内容提取到父類的構造方法中做,因為潛艇寬高有不同,做成形式参數,具體由調用該構造方法的子類决定寬高的數據是多少.

##### 在SeaObject類中,做一個專門為潛艇類提供的構造方法

```java
 /**
     * 此構造方法是專門為三種潛艇提供的構造方法
     * 因為三種潛艇的寬高不同,所以做成形式参數,具體的數據由使用的子類來决定.
     */
    SeaObject(int width, int height) {
        this.width = width;
        this.height = height;
        x = -width;
        y = (int) (Math.random() * (479 - height - 150) + 150);
        speed = (int) (Math.random() * (3 - 1) + 1);
    }
```

##### 具體潛艇類調用父類的構造方法:

```java
   MineSubmarine() { //水雷潛艇類構造方法
        super(63,19);
    }

   ObserverSubmarine() { //偵察潛艇類構造方法
        super(63,19);
    }

   TorpedoSubmarine() { //魚雷潛艇類構造方法
        super(64,20);
    }
```

##### 在SeaObject類中,做一個專門為戰艦類,魚雷類,水雷類,炸彈類提供的構造方法

```java
 /**此構造方法是專門為戰艦類,炸彈類,魚雷類,水雷類提供的構造方法
     *因為這4個類的具體數據都不同,所以做成5個形式参數的構造方法,具體為對象賦值的内容由子類决定.
     */
    SeaObject(int x, int y, int width, int height, int speed) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.speed = speed;
    }
```

##### 具體戰艦類,魚雷類,水雷類,炸彈類調用父類提供的構造方法:

```java
  Battleship() {//戰艦類只會存在一個對象,且一開始戰艦的位置,大小,速度,生命值都可以確定
        super(270,124,66,26,20);
        life = 5;
    }
   Bomb(int x,int y){//因為炸彈被創建時 x y 不確定,所以創建對象時决定當前對象所在的位置。
        super(x,y,9,12,3);
    }
  Mine(int x, int y) {
        super(x,y,11,11,2);
    }
 Torpedo(int x, int y) {
        super(x,y,5,18,2);
    }
```

--------

##### 構造方法的強化練習:

> ```
> 1.創建學生對象 老師對象,醫生對象 為對象依次打點賦值的過程比較麻煩,如何解决? 通過構造方法解决
> 2.實現第一步後,發現學生類 老師類 醫生類的構造方法内容有重複,如何解决?  通過父類構造方法複用解决
> ```

##### 3個子類的構造方法:

```java
Person(String name,int age,char sex){//父類中的構造方法  讓子類複用的賦值邏輯
        this.name = name;
        this.age = age;
        this.sex = sex;
    }
------------------------------------------------
Student(String name,int age,char sex,int stuID){  //學生類構造方法
        super(name, age, sex);//調用父類提供的構造方法完成對當前學生對象賦值
        this.stuID =stuID;
    }
------------------------------------------------
Teacher(String name,int age,char sex,double salary){//老師類的構造方法
        super(name, age, sex);//調用父類提供的構造方法完成對當前老師對象賦值
        this.salary =salary;
    }
-------------------------------------------------
 Doctor(String name,int age,char sex,int level){//醫生類的構造方法
        super(name, age, sex);//調用父類提供的構造方法完成對當前醫生對象賦值
        this.level =level;
    }
```

##### 問題:在以下測試代碼中,我們會發現,因為有三個數組,老師數組,醫生數組,學生數組,那麼想要遍歷數組中每個對象的sayHi方法,是需要寫3個for循環來完成.for循環的過程是冗余的重複的.

##### 解决: 把3個數組變成一個數組 就能使用一個for循環來解决問題. -----向上造型

```java
        Student[] students = new Student[2];
        students[0] = new Student("張三",28,'男',1001);
        students[1] = new Student("張四",48,'男',1002);
        for (int i = 0; i < students.length; i++) { //for快捷鍵 foriEnter
             students[i].sayHi();//調用學生數組中每個對象的sayHi方法
        }

        Teacher[] teachers = new Teacher[2];
        teachers[0] = new Teacher("李四",38,'男',1000000000);
        teachers[1] = new Teacher("李二",48,'男',100999999);
        for (int i = 0; i < teachers.length; i++) {
            teachers[i].sayHi();//調用老師數組中每個對象的sayHi方法
        }
        Doctor[] doctors = new Doctor[2];
        doctors[0] = new Doctor("王五",58,'男',12);
        doctors[1] = new Doctor("老王",38,'男',16);
        for (int i = 0; i < doctors.length; i++) {
            doctors[i].sayHi();//調用醫生數組中每個對象的sayHi方法
        }
```

#### 向上造型

> 向上造型的語法前提是有繼承關係。

1. ##### 聲明父 new 子對象 的語法就是向上造型.

2. ##### 父 大  子  小

##### 好處：通過父類型 來管理不同的子對象,簡化代碼的編寫。

```java
class Animal{ //動物類    父類
    
}

class Tiger extends Animal{//老虎類    子類
    
}

main{
    類型            對象
    Animal a = new Animal();//動物 是 動物    -----語義通  意味程序中不會報錯
    Tiger  t = new Tiger();// 老虎 是 老虎    -----語義通
    
    Animal a1 = new Tiger();//老虎 是 動物    -----語義通  
    
    Tiger  t1 = new Aniaml();//動物 是老虎   -----語義不通..程序中會報錯.
    
}
---------
      //聲明父     new  子對象
        Person p1 = new Student("張三",28,'男',1001);
        Person p2 = new Teacher("李四",38,'男',1000000000);
        Person p3 = new Doctor("王五",58,'男',12);
        //創建了一個(父)Person類型數組  開闢3塊空間
        Person[] pp = new Person[3];
        pp[0]  =  new Student("張三",28,'男',1001);
        pp[1]  =  new Teacher("李四",38,'男',1000000000);
        pp[2]  =  new Doctor("王五",58,'男',12);
        for (int i = 0; i < pp.length; i++) {
            pp[i].sayHi();
        }

```

##### 解决項目中數組較多的問題，因為三種潛艇後續功能是一樣的,二種雷後續功能是一樣的,所以可以使用兩個父類型數組來代表這些對象。

```java
    SeaObject[] submarines;//該數組代表以後三種潛艇類型的對象。
    SeaObject[] thunders;//該數組代表以後二種雷類型的對象
    void action() {//普通方法
        submarines = new SeaObject[6];
        submarines[0] = new ObserverSubmarine();
        submarines[1] = new ObserverSubmarine();
        submarines[2] = new TorpedoSubmarine();
        submarines[3] = new TorpedoSubmarine();
        submarines[4] = new MineSubmarine();
        submarines[5] = new MineSubmarine();
        for (int i = 0; i < submarines.length; i++) {
             submarines[i].step();
        }
        thunders = new SeaObject[4];
        thunders[0] = new Mine(20, 30);
        thunders[1] = new Mine(20, 40);
        thunders[2] = new Torpedo(30, 50);
        thunders[3] = new Torpedo(30, 60);
        for (int i = 0; i < thunders.length; i++) {
            thunders[i].step();
        }
    }
```

##### 問題：不管是項目中測試還是繼承測試,打印的信息不明確,無法知道具體的子類信息。原因在於父類無法明確子類特有的行為邏輯.

#### 父類中提供的某一種行為邏輯子類不適用。

### 重寫(Override)

##### 適用性：當實現繼承後,子類無法複用父類的行為中邏輯代碼時,子類可以通過重寫父類的方法來定義完成自己的邏輯代碼。

- ##### 重寫的語法：簡單重寫,子類重寫父類方法時,跟父類的方法結構保持相同即可。

- ##### 重寫執行現象：調用父執行子。

- ##### 重寫規則遵循兩同兩小一大原則：

  - ##### 兩同：子類重寫父類方法時,方法名和参數列表要相同

  - ##### 兩小：

    - ##### 子類重寫父類方法時,重寫的方法中返回的數據要等於或小於父類方法的返回值類型。

    - ##### 子類重寫父類方法時,重寫的方法中抛的異常要等於或小於父類方法的異常。

  - ##### 一大：子類重寫父類方法時,訪問權限要等於或大於父類中的那個方法。

```java
學生類重寫：
     void sayHi() { //重寫父類的sayHi方法。
        System.out.println("我是一名學生,我叫:"+ name + ",今年:" + age + "歲了！,我的性别是:" + sex+",我的學號是"+stuID);
    }
老師類重寫：
      @Override
    void sayHi() {
        System.out.println("我是一名老師,我叫:"+ name + ",今年:" + age + "歲了！,我的性别是:" + sex+",我的工資是"+salary);
    }
醫生類重寫：
      @Override
    void sayHi() {
        System.out.println("我是一名醫生,我叫:"+ name + ",今年:" + age + "歲了！,我的性别是:" + sex+",我的職級是"+level);
    }
```

##### 項目中7個子類分别重寫父類中的step方法：

```java
@Override
    void step() { //戰艦類重寫
        System.out.println("戰艦對象通過鍵盤左右運動...");
    }
-----------
       @Override
    void step() {//深水炸彈類重寫
        System.out.println("炸彈對象y向下運動.....");
    }
-----------
     @Override
    void step() {//水雷類重寫
        System.out.println("水雷對象y向上運動.....");
    }
------------
    @Override
    void step() {//水雷潛艇類
        System.out.println("水雷潛艇對象x向右運動.....");
    }
    @Override
    void step() {//偵察潛艇類
        System.out.println("偵察潛艇對象x向右運動.....");
    }
    @Override
    void step() {//魚雷潛艇類
        System.out.println("魚雷潛艇對象x向右運動.....");
    }
---
      @Override
    void step() {//魚雷類
        System.out.println("魚雷對象y向上運動.....");
    }
    
```

#### 重寫的強化：

```java
重寫的情况分類：
    		1.Boo子類 只想吃西餐   ------不需要重寫
    	    2.Boo子類 只想喝果汁   ------需要重寫
            3.Boo子類 想吃西餐又想喝果汁----需要重寫
class Aoo{ //父類
    void eat(){
        System.println("吃西餐");
    }
}
class Boo extends Aoo{//子類
    void eat(){
        super.eat();//調用父類中的方法
        System.println("喝果汁");
    }
}
main{
    Boo b = new Boo();
    b.eat();
}
    
```

#### 重載和重寫的區别：

##### 重載(Overload/Overloading): 發生在同類中, 方法名相同,参數個數或参數類型 不同!

##### 重寫(Override/Overriding): 發生在父子關係中,方法名相同,参數個數和参數類型 相同!

```java
class Aoo{
    void show(){
        
    }
}
class Boo extends Aoo{
    void show(){//重寫
        
    }
}
-----------------------
class Aoo{
    void show(){
        
    }
}
class Boo extends Aoo{
    void show(int a){//重載
        
    }
}    
```

### 畫窗口

##### 畫窗口需要用到的界面的繪製相關的功能不需要掌握,工作也不同.

1. ##### 提供了畫框和底板的功能.

   ```java
   import javax.swing.JFrame;//畫框功能   導入
   import javax.swing.JPanel;//底板功能   導入
   ```

2. ##### GameWorld類繼承Jpanel類

   ```java
   GameWorld extends JPanel
   ```

3. ##### 寫繪製窗口的邏輯代碼

```java
 /**
     * 繪製窗口的方法   在main中調用
     */
    void paintWorld(){
  	    JFrame jFrame = new JFrame();//創建畫框對象
        this.setFocusable(true);//窗口狀態可聚焦
        jFrame.add(this);//畫框添加底板
        jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//窗口關閉並停止程序運行
        jFrame.setSize(641+16,479+39);//設置窗口大小
        jFrame.setLocationRelativeTo(null);//設置窗口居中畫面
        jFrame.setVisible(true);//啟動窗口
    }
```

#### package (包)

##### 如果不用包,那麼一個大項目中,需要起不同名字的類文件。如果把類名作唯一標識,很有可能出現衝突。

##### 1000個類如果起1000個類名太麻煩,Java設計了package就可以解决同名類文件問題。

##### 作用：避免類名衝突.

##### 現象：同包中不允許出現同名的類文件。

##### 包名：建議纯小寫 ,工作時包命名建議 ： 域名反寫.項目名稱.模塊名稱.類名

##### 類全包名：包名.類名

```java
package day01;
class Aoo{  //  day01.Aoo   類的全包名
    
}

package day02;
class Aoo{ //  day02.Aoo    類的全包名
    
}

```

#### import 

> import 表示導入

##### 適用性：當前類需要用到某些功能時,而這些功能不在當前類的同包中,那麼則需要通過import導入要使用的功能類的全包名 才可以使用。

##### 快捷導入：選中使用的功能 alt + Enter

- ##### 如果使用的是同包類的文件時,無需導包直接使用。

#### 訪問修飾符

> 控製代碼的可掃範圍,目的保護程序的合法性,安全性,健壯性！

##### 迪米特原則："不要和陌生人說話" ,類的成員(屬性/方法)能私有盡量私有。

##### 屬性的封裝：屬性私有化,方法公開化，對外提供get 獲取的方法   set設置的方法

##### public 公開的 ：任意地方都可以訪問

##### protected  保護的： 當前類/同包類/ 子類 可掃

##### 默認的：當前類/同包類

> 工作中不建議使用默認的訪問權限。

##### private 私有的：當前類

```java

class Card{//卡類
    private int carID;//賬戶
    private int cardPwd;//密碼
    private int balance;//餘額
    
    public void setBalance(int money){
        if(money >0){
            balance += money;
        } 
    }
    
    public int getBalance(){
        return balance;
    }
    
    public boolean payMoney(int money){
        if(balance >= money){
            balance -= money;
            return true;
        }else{
            System.out.println("卡裡餘額不足...");
            return false;
        }
    }
    
    public boolean checkPwd(int pwd){
        if(cardPwd == pwd){
            return true;//
        }else{
            System.out.println("密碼輸入錯誤...");
            return fasle;
        }
    }
    
}

```

```java
package oo.test01;
/**訪問修飾符測試：
 *public公開的 ：   任意地方都可以訪問
 *protected保護的： 當前類/同包類/ 子類 可訪問
 *默認的：          當前類/同包類 可訪問
 *private私有的：   當前類  可訪問
 */
public class Aoo {
    public int a;//公開的
    protected  int b;//保護的
    int c;//默認的
    private int d;//私有的
    void show(){
        a = 1;//當前類可掃
        b = 1;//當前類可掃
        c = 1;//當前類可掃
        d = 1;//當前類可掃
    }
}
class Boo{ //同包類
    void show(){
        Aoo aoo = new Aoo();
        aoo.a = 1;
        aoo.b = 2;
        aoo.c = 3;
//        aoo.d = 4; 私有的成員 同包類不可掃
    }
}
```

##### test02測試：

```java
package oo.test02;
import oo.test01.Aoo;
public class Coo { //非同包類測試
    void show(){
        Aoo aoo = new Aoo();
        aoo.a = 1; //可訪問公開的
//        aoo.b = 2;非同包類不可訪問 保護的
//        aoo.c = 3;非同包類不可訪問 默認的
//        aoo.d = 4;非同包類不可訪問 私有的
    }
}

class Doo extends Aoo{
     void show(){
         a = 1; //可訪問公開的
         b = 2;//實現繼承可直接使用 保護級别的成員
//         c = 3; 不可訪問默認的
//         d = 4; 不可訪問私有的
     }
}
```

```java
訪問修飾符				當前類		同包類		子類		非同包類
public                   √		    √        √         √ 	 
protected                √		    √        √
默認的                    √		  √  
private                  √  
```

#### final 關鍵字

> final代表最終的

##### 修飾屬性：用final修飾的屬性,不可二次修改,且聲明時需要初始化。

##### 修飾方法：用final修飾的方法,不能夠被重寫。   ----只應用在父級代碼中

##### 修飾類：    用final修飾的類 , 不能被繼承。

```java
package oo.day03;

/**
 * final的使用演示類
 */
public class FinalDemo {
   private final int a = 100;//final修飾的變數聲明時需初始化 且不能二次修改
   void show(){
       System.out.println(a);
//      a = 200;不可二次修改
   }
}
final class Aoo{ //final 修飾的類不能被繼承
    final void show(){ //final修飾的方法不可被重寫

    }
}
class Boo /**extends Aoo*/ {
//    @Override
//    void show() {
//        System.out.println("重寫Aoo類的show方法");
//    }
}
```

#### static(静態)

##### 每個學生手裡拿的杯子,都屬於當前對象的。 ------->實例資源

##### 飲水機不屬於對象的,但可以被對象共享 。    ------->静態資源

#### 静態變數

> ##### 用static修飾的變數,稱之為静態變數

##### 静態變數適用性:當有一份數據,多個對象都需要使用,我們可以做成静態變數.

- ##### 變數分類

  - ##### 實例變數：屬於對象的,有多少個對象就有多少份,在堆區儲存,訪問則通過對象打點訪問。

  - ##### 静態變數：屬於當前類,且只有一份被所有對象共享,在方法區中儲存, 訪問則通過類名打點訪問。

- ##### 一個類對應的.class字節碼文件,會在當前類被首次使用時,加載到方法區中,且只加載一次.

```java
JVM 劃分三塊内存區域：
棧區：存放局部變數
堆區：存放對象區域
方法區：用來加載類.class字節碼文(類中的静態成員(静態方法,静態變數),普通方法,構造方法)    
```

```java
package oo.day03;

/**
 * 静態變數的使用演示類：
 */
public class StaticVarDemo {
    public static void main(String[] args) {
        Coo c1 = new Coo();
        c1.show();
        Coo c2 = new Coo();
        c2.show();
        Coo c3 = new Coo();
        c3.show();

        System.out.println(c1.a);//訪問實例變數
        System.out.println(Coo.b);//訪問静態變數
    }
}
class Coo {
    public int a;//實例變數,屬於對象的.
    public static int b;//静態變數,屬於類的.
    Coo() {
        a++;
        b++;
    }
    public void show() {
        System.out.println("實例變數a值:" + a + " , 静態變數b值:" + b);
    }
}
```

#### 静態方法

> 用static修飾的方法,稱之為静態方法

##### 静態方法的適用性：静態方法一般存在工具類中,對於外部使用比較方便,無需創建對象使用。

- ##### 静態方法是屬於類的,訪問則通過類名打點訪問.

- ##### 静態方法儲存在方法區中.

- ##### 静態方法沒有this傳遞,所有静態方法無法直接訪問實例成員(普通方法,實例變數)

```java
package oo.day03;

/**
 * 静態方法的使用演示類:
 */
public class StaticMethodDemo {
    public static void main(String[] args) {
        Math.random();
        Doo.show2();//類名打點調用
    }
}
class Doo{
    public int a;//實例變數
    public static int b;//静態變數
    public void show(){ //自定義的普通方法
        this.a = 1; //實例成員 隱式寫法 this.
        b = 1;//静態成員 隱式寫法 類名.
    }
    public static void show2(){//静態方法沒有this傳遞  不能使用this
//        this.a = 1; //實例成員 隱式寫法 this.
          b = 1;//静態成員 隱式寫法 類名.
    }
}
```

#### 静態代碼塊

##### 静態代碼塊的適用性：可以對一些静態資源在當前類不需要被創建對象的情况下可以完成静態資源初始化。

- ##### 用static修飾的代碼塊稱之為静態代碼塊

- ##### 静態代碼塊屬於類的,當當前類字節碼文件被首次加載時,會自動執行静態代碼塊(且只執行一次)

```java
static { //静態代碼塊
    
}
---
    package oo.day03;

/**
 * 静態方法的使用演示類:
 */
public class StaticMethodDemo {
    public static void main(String[] args) {
        System.out.println(Doo.b );//調用静態成員b
    }
}
class Doo{
    public static int b;//静態變數
    Doo(){ //構造方法作用：可以為實例變數初始化賦值 當類被創建對象時執行 
        System.out.println("這是Doo類的構造方法");
    }
    static {//静態代碼塊作用：可以為静態變數初始化賦值 當類被首次加載時執行,且只執行一次
        b = 100;
        System.out.println("這是Doo類的静態代碼塊");
    }
}
```

##### 項目需要圖片資源,項目中需要圖片進行顯示以及繪製的操作,所以這些圖片資源要分别存在静態變數中,後期需要用到圖片的地方通過類名直接打點使用。

##### 在項目包下創建一個ImageResource類。

```java
package cn.tedu.submarine;

import javax.swing.*;

/**
 * 圖片加載資源類：
 * 負責對項目中所需要用到的圖片初始化,對外提供静態圖片
 */
public class ImageResource {
    //用來儲存圖片資源的類型 ImageIcon
    public static ImageIcon battleship;     //聲明一個戰艦圖片類型的静態變數
    public static ImageIcon bomb;           //聲明一個炸彈圖片類型的静態變數
    public static ImageIcon gameover;       //聲明一個遊戲结束圖片類型的静態變數
    public static ImageIcon mine;           //聲明一個水雷圖片類型的静態變數
    public static ImageIcon minesubm;       //聲明一個水雷潛艇圖片類型的静態變數
    public static ImageIcon obsersubm;      //聲明一個偵察潛艇圖片類型的静態變數
    public static ImageIcon sea;            //聲明一個海洋背景圖片類型的静態變數
    public static ImageIcon start;          //聲明一個遊戲開始圖片類型的静態變數
    public static ImageIcon torpedo;        //聲明一個魚雷圖片類型的静態變數
    public static ImageIcon torpesubm;      //聲明一個魚雷潛艇圖片類型的静態變數

    static { //静態代碼塊
        battleship = new ImageIcon("img/battleship.png");
        bomb = new ImageIcon("img/bomb.png");
        gameover = new ImageIcon("img/gameover.png");
        mine = new ImageIcon("img/mine.png");
        minesubm = new ImageIcon("img/minesubm.png");
        obsersubm = new ImageIcon("img/obsersubm.png");
        sea = new ImageIcon("img/sea.png");
        start = new ImageIcon("img/start.png");
        torpedo = new ImageIcon("img/torpedo.png");
        torpesubm = new ImageIcon("img/torpesubm.png");
    }
}
```

#### 常量

##### 常量適用性:當一份數據確定下來,幾乎不會發生改變時,可以做成常量來表示. 1.方便使用   2.數據穩定

##### 用static final修飾的變數稱之為常量,结合了static 和final的特點。

##### 特點: 只有一份且通過類名來訪問,不能二次修改,聲明時需要初始化

##### 常量命名要求: 全大寫,且每個單詞之間可以用下劃線隔開.

```java
package oo.day03;

/**
 * 常量的使用演示類
 */
public class StaticFinalDemo {
    public static void main(String[] args) {
        //1.先將Eoo.class字節碼文件加載到方法區
        //2.輸出静態變數a的值  0
//        System.out.println(Eoo.a);//訪問静態變數

        //在編譯期間本質就已經把常量的數據轉換為具體的數值.
        System.out.println(Eoo.C);//訪問常量
//        System.out.println(200);
    }
}

class Eoo {
    public static int a;//静態變數
    public final int b = 10;//用final修飾的變數不可二次修改
    public static final int C = 200;//常量  通過類名打點使用,不可二次修改
    static {
        System.out.println("Eoo類的静態代碼塊執行了....");
    }
}
```

##### 項目中窗口的大小是固定的,而且後期需要訪問窗口大小的數據也頻繁,所以可以直接將窗口大小做成常量.

```java
    public static final int WIDTH = 641;
    public static final int HEIGHT = 479;
```

### 總结設計規則

- ##### 類的封裝: 將同一類别下多個對象共有的屬性和行為提取到一個模板中.

- ##### 類的繼承: 多個模板之間存在共有的屬性和行為時,且概念上是一種的關係時,提取到父類.

  - ##### 提取到父類中的行為,如果具體的行為代碼子類都能複用,   做成普通方法.

  - ##### 提取到父類中的行為,如果具體的行為代碼子類都不能複用,做成抽象方法.

1. ##### 從軟體設計的角度講：先有抽象方法再有抽象類

2. ##### 從編碼實現的角度講：先有抽象類再有抽象方法

### 抽象方法

1. ##### 用abstract修飾的方法稱之為抽象方法

2. ##### 抽象方法只能存在於抽象類中    (Abstract method in non-abstract class)

3. ##### 抽象方法不能有代碼塊               ( Abstract methods cannot have a body)

4. ##### 抽象方法是必須要求子類實現重寫！

### 抽象類

1. ##### 用abstract修飾的類稱之為抽象類

2. ##### 抽象類是無法被創建對象

   ```java
   //       SeaObject s = new SeaObject();不能創建SeaObject對象
          SeaObject[] seaObjects = new SeaObject[3];//可以創建SeaObject類型數組對象
   ```

3. ##### 抽象類只是在普通類的基礎上多放抽象方法

4. ##### 抽象類需要被子類繼承實現抽象方法

--------

##### 抽象方法有意義嗎？

1. ##### 抽象方法有意義嗎? 普通方法不也可以？

   ##### 答：遵循面向對象的設計原則,滿足子類都不能用該行為的邏輯時,設計抽象方法的目的就是约束子類必須重寫。

2. ##### 既然重寫了,父類的抽象方法還有存在的必要嗎？

   ##### 答：父類存在的方法就是為了向上造型。

#### 畫對象

1. ##### 需要對象圖片

2. ##### 繪製的坐標

- ##### 每個對象都需要獲取圖片,獲取圖片的行為應該由各個子類來完成,每個子類都需要有獲取圖片的行為,提取父類中,做成抽象方法.

  ```java
  protected abstract  ImageIcon  getImage();
  ```

- ##### 每個對象都會有狀態稱之為固定狀態,活著的狀態 死亡的狀態  用 常量表示.

  ##### 當前狀態表示是實際的狀態  可以用變數表示.

  ```java
      public static final int LIVE = 0;//活著的狀態
      public static final int DEAD = 1;//死亡的狀態
  
      public int currentStatus = LIVE;//默認對象是活著的狀態
  ```

  ##### 父類提供判斷當前對象是否是活著和是否是死亡狀態的方法:

  ```java
  /** 判斷當前對象是否是活著的狀態的方法 */
      public boolean isLive(){
          return currentStatus == LIVE;
      }
      /** 判斷當前對象是否是死亡的狀態的方法 */
      public boolean isDead(){
          return currentStatus == DEAD;
      }
  ```

- ##### 實現第三步,各個子類進行重寫父類中的獲取圖片的方法

  ```java
  戰艦類:
   @Override
      protected ImageIcon getImage() {//因為戰艦比較特殊,如果是死亡狀態遊戲就结束了
          return ImageResource.battleship;//返回戰艦圖片
      }
  深水炸彈類:
   @Override
      protected ImageIcon getImage() {
          if(isLive()){
              return ImageResource.bomb;//返回深水炸彈圖片
          }
          return null;//如果代碼能執行到這一行則表示當前炸彈對象是死亡狀態 返回null
      }
  水雷類:
   @Override
      protected ImageIcon getImage() {
          if(isLive()){//如果當前對象是活著的狀態
              return ImageResource.mine;//返回水雷圖片
          }
          return null;//如果代碼能執行到這一行則表示當前水雷對象是死亡狀態 返回null
      }
  水雷潛艇類:
   @Override
      protected ImageIcon getImage() {
          if(isLive()){//如果當前對象是活著的狀態
              return ImageResource.minesubm;//返回水雷潛艇圖片
          }
          return null;//如果代碼能執行到這一行則表示當前水雷潛艇對象是死亡狀態 返回null
      }
  偵察潛艇類:
   @Override
      protected ImageIcon getImage() {
          if(isLive()){//如果當前對象是活著的狀態
              return ImageResource.obsersubm;//返回偵察潛艇圖片
          }
          return null;//如果代碼能執行到這一行則表示當前偵察潛艇對象是死亡狀態 返回null
      }
  魚雷類:
    @Override
      protected ImageIcon getImage() {
          if(isLive()){//如果當前對象是活著的狀態
              return ImageResource.torpedo;//返回魚雷圖片
          }
          return null;//如果代碼能執行到這一行則表示當前魚雷對象是死亡狀態 返回null
      }
  魚雷潛艇類:
   @Override
      protected ImageIcon getImage() {
          if(isLive()){//如果當前對象是活著的狀態
              return ImageResource.torpesubm;//返回魚雷潛艇圖片
          }
          return null;//如果代碼能執行到這一行則表示當前魚雷潛艇對象是死亡狀態 返回null
      }
  
  ```

- ##### 目前每個對象都需要被繪製,那麼就意味著每個對象都應該有繪製的行為,所以可以提取到父類中來定義繪製的行為

  ```java
   public void paintImage(Graphics g){
          //1.獲取對象圖片
          ImageIcon icon = this.getImage();//獲取當前對象的圖片
          if(icon != null){ //判斷獲取的圖片不為null
              //2.繪製圖片所在的位置   null,g,x , y
              icon.paintIcon(null, g, this.x, this.y);
          
      }
  ```

- ##### 測試:

  ```java
    @Override
      public void paint(Graphics g) { //係統提供的繪製方法   g---畫筆
          ship.paintImage(g);
          System.out.println(1);
          for (int i = 0; i < thunders.length; i++) {
              thunders[i].paintImage(g);
          }
   
      }
  
  ```



#### 内部類

- ##### 成員内部類

1. ##### 内部類對外不具備可掃性

2. ##### 内部類共享外部類成員。如果内部類成員和外部類成員命名衝突時,默認使用時遵循就近原則。明確訪問外部類成員 可以使用 外部類名.this.xx 來表示

3. ##### 内部類可以在對應的外部類中創建對象

```java
class Aoo{//外部類   相對於Boo類
    
    class Boo{  //内部類   
    }    
}
---
    package oo.day04;
/**
 * 成員内部類測試：
 */
public class MemberInnerClassDemo {
    public static void main(String[] args) {
//        Aoo.Boo boo = new Aoo.Boo(); 無法創建Boo内部類對象
    }
}
class Aoo{
    private int a;//外部類成員變數
    private void show(){//外部類普通方法
        Boo b = new Boo();//外部類可以創建内部類對象
    }
    class Boo{//内部類
        private int a;
        void test(){
//          a = 1; //内部類共享外部類成員
            a = 1;//如何成員命名衝突,默認使用的最近的
            Aoo.this.a = 2;//明確訪問外部類成員時： 外部類名.this.xx
//            show();
        }
    }
}
```

- ##### 匿名内部類(重點)

##### 適用性：當如果一個子類僅僅只是為了重寫父類中的某個行為,其它地方根本不用該子類,那麼我們可以用匿名内部類來實現重寫的邏輯。好處可以讓程序面向邏輯編程,忽略語法。

1. ##### 匿名内部類的寫法可以應用在  類,抽象類,接口 這些父類基礎上進行使用。

2. ##### 匿名内部類使用外部類成員時默認修飾為final,只能用不能改。

```java
package oo.day04;
/**
 * 匿名内部類的使用演示類：
 */
public class NSInnerClassDemo {
    public static void main(String[] args) {
//        SuperDemo s = new SubDemo();
//        s.show();
        int abc = 100;
//        abc = 99;
        //使用匿名内部類簡化重寫步驟：
        //1.創建SuperDemo的匿名子類對象,只不過沒名字
        //2.將子類對象 賦值給 sub變數
        //3.該花括號則就是該子類的類體
        SuperDemo sub = new SuperDemo(){ //該匿名内部類的外部類是 NSInnerClassDemo
            @Override                    //該匿名内部類的父類是  SuperDemo
            void show() {
                System.out.println(abc);//匿名内部類訪問外部類變數 會自動修飾為final特點
                System.out.println("匿名内部類中重寫父類的show方法");
            }
        };
        sub.show();//調用父執行子
    }
}
abstract class SuperDemo{
    abstract void show();
}
/** 1.創建一個類  2.實現繼承SuperDemo  3.實現重寫*/
class SubDemo extends SuperDemo{
    @Override
    void show() {
        System.out.println("重寫SuperDemo父類中的show方法");
    }
}
```

##### 需要動態(自動)生成對象,動態(自動)移動：

- ##### 自動生成對象：偵察潛艇,魚雷潛艇,水雷潛艇,魚雷,水雷

- ##### 自動移動對象：偵察潛艇,魚雷潛艇,水雷潛艇,魚雷,水雷,深水炸彈

#### 想要實現自動發生可以通過：

1. ##### 定時器

2. ##### 線程(第二階段講)

#### 定鬧鐘

##### 1.布置鬧鐘任務      2.設定任務延時的時間(延時多久執行) 	  3.鬧鐘執行一次任務後距下次執行的間隔時間

----



#### 定時器

##### 1.具體執行的任務   2.延時多久執行任務  3.執行一次後距下次的間隔時間

##### Java提供了一個任務模板類,提供一個定時器類：

```java
import java.util.TimerTask;//任務模板類
import java.util.Timer;//定時器類

```

##### 測試：

```java
 private void action() {//普通方法
        Timer timer = new Timer();//創建一個定時器對象
        TimerTask task = new TimerTask() { //創建任務子類 在子類重寫run方法 部署具體的任務邏輯
            @Override
            public void run() { //具體要自動執行的任務方法
                System.out.println("叮叮叮~~~~");
            }
        };
        //1.具體執行的任務   2.延時多久執行任務(毫秒)  3.執行一次後距下次的間隔時間(毫秒)
        timer.schedule(task, 5000, 2000);
    }
```

#### 數組擴容

> 數組容量一旦確定是不可變的,我們所實現的擴容本質是產生了新的數組對象！

```java
package oo.day04;

import java.util.Arrays;

/**
 * 數組拷貝的使用演示類：
 * Arrays.copyOf();   --------------基於源數組的内容基礎上擴容或縮容的情况下使用。
 * System.arrayCopy();--------------已知兩個數組  例如 A數組向B數組拷貝内容使用.
 */
public class ArrayCopyDemo {
    public static void main(String[] args) {
        /**Arrays.copyOf();
         *
         */
        int[] array = {10,20,30};//創建一個長度為3的數組對象  賦值array
        System.out.println("擴容前數組長度:" + array.length);
        int a = 100;
        //copyOf();  1.處理源數組   2.基於源數組的長度 擴容(+1)還是縮容(-1)
        array = Arrays.copyOf(array, array.length + 1);//此代碼會產生新的數組對象 需要賦值影響源數組
        System.out.println("擴容後數組長度:" + array.length);
        //array.length - 1 該下標表示 數組最後一塊空間 在當前代碼中指的就是擴容後的位置
        array[array.length - 1] = a;
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
  		  /** System.arrayCopy();
         *
         */
        int[] arrA = {10, 20, 30, 40, 50};
        int[] arrB = {0 , 0 ,  0,  0, 0 };
        /**arraycopy方法需要5個参數
         *  1.需要拷貝的源數組
         *  2.從拷貝的源數組哪個下標開始拷貝
         *  3.拷貝的目標數組
         *  4.從目標數組哪個下標開始裝載
         *  5.拷貝的長度   (目標數組長度 - 從目標數組裝載的下標) 前提是源數組從頭開始裝載
         *    拷貝的長度 不能超過 目標數組 和 源數組 處理的長度
         *    否則會報ArrayIndexOutOfBoundsException 數組訪問越界異常
         */
        System.arraycopy(arrA,0,arrB,0,arrB.length - 0);
        for (int i = 0; i < arrB.length; i++) {
            System.out.println(arrB[i]);
        }
    }
}
```

#### 自動入場相關的實現

- ##### 潛艇入場

  - ##### 創建潛艇對象方法

    ```java
     /**
         * 創建潛艇對象的方法
         * 返回值不能寫某個具體的潛艇類型,因為該方法會返回不同的潛艇對象
         * 所以返回值寫父類型  父類型可以代表不同的子對象。
         */
        private SeaObject createSubmarine() {
            /** 練習：
             *  1.隨機產生 0 ~ 20的隨機整數
             *  2.如果產生的隨機數小於10 返回偵察潛艇對象
             *    否則如果產生的隨機數小於15 返回魚雷潛艇對象
             *    否則返回水雷潛艇對象
             */
            int type = (int) (Math.random() * 20);
            if(type < 10){
                return new ObserverSubmarine();//返回偵察潛艇對象
            }else if(type < 15){
                return new TorpedoSubmarine();//返回魚雷潛艇對象
            }else {
                return new MineSubmarine();//返回水雷潛艇對象
            }
        }
    ```

  - ##### 潛艇入場的邏輯方法

    1. ##### 調用創建潛艇對象的方法接收該方法返回的潛艇對象

    2. ##### 將submarines數組擴1容量

    3. ##### 將接收的潛艇對象 賦值給擴容後的位置

    ```java
     private int submarineEnterIndex = 0;//控製潛艇產生的速度
        /**
         * 潛艇入場的方法實現           --------該方法在run中調用
         */
        private void submarineEnterAction() { //每10毫秒調用一次
            /**
             * 1 調用創建潛艇對象的方法接收該方法返回的潛艇對象
             * 2 將submarines數組擴1容量
             * 3 將接收的潛艇對象 賦值給擴容後的位置
             */
            submarineEnterIndex++;//每10毫秒自增1次
            if (submarineEnterIndex % 40 == 0) { //每400毫秒執行一次 0.4s
                SeaObject obj = createSubmarine();//1.
                submarines = Arrays.copyOf(submarines, submarines.length + 1);//2.
                submarines[submarines.length - 1] = obj;//3.
            }
        }
    ```

  - ##### 讓paint方法刷新繪製,數組中對象則顯示在窗口中

    ```java
    private void action() {//普通方法
            Timer timer = new Timer();//創建一個定時器對象
            TimerTask task = new TimerTask() { //創建任務子類 在子類重寫run方法 部署具體的任務邏輯
                @Override
                public void run() { //具體要自動執行的任務方法
                    submarineEnterAction();//調用潛艇入場的方法
                    //移動的方法
                    repaint(); //重新執行一次paint方法
                }
            };
            //1.具體執行的任務   2.延時多久執行任務(毫秒)  3.執行一次後距下次的間隔時間(毫秒)
            timer.schedule(task, 5000, 10);//0.01s
        }
      
    ```

- ##### 雷入場

  - ##### 創建雷對象的方法,因為水雷由水雷潛艇產生，魚雷由魚雷潛艇產生,因為行為一致,可以放到父類中做一份。

  ```java
   /** 發射雷的方法 返回值寫父類型
       *  該方法由潛艇調用：
       *  水雷潛艇調用該方法  返回水雷對象
       *  魚雷潛艇調用該方法  返回魚雷對象
       *  偵察潛艇調用該方法  返回null
       */
      public SeaObject shootThunder(){
          int x = this.x + this.width;//雷的x坐標
          int y = this.y  - 5;//雷的y坐標
          // instanceof 關鍵字：用來判斷當前對象 是否是某個類型的
          if( this instanceof MineSubmarine){//如果當前對象 是 水雷潛艇類型
              return new Mine(x,y);//返回水雷對象
          }else if(this instanceof TorpedoSubmarine){//如果當前對象 是 魚雷潛艇類型
              return new Torpedo(x,y);//返回魚雷對象
          }else {
              return null;//如果代碼能執行到這一行 則返回null
          }
      }
  ```

  - ##### 雷入場的方法   ----自行實現：在GameWorld類中定義一個雷入場的方法 

    - ##### 無参無返回值  方法名thunderEnterAction

      - ##### 1.循環遍歷潛艇數組的每個對象並調用發射雷對象的方法接收返回雷對象

      - ##### 2.在循環中判斷接收的雷對象不為null

      - ##### 3.不為null則將thunders數組擴一個容量

      - ##### 4.將接收的雷對象賦值給 擴容後的位置

  - ##### 將雷入場的方法在run中調用並刷新繪製

  - ##### 控製雷產生的速度参考雷產生的速度代碼 ,雷1000毫秒創建一次。 thunderEnterIndex 

```java
private int thunderEnterIndex = 0;//控製雷產生速度的索引
    /**
     * 雷入場的方法           ----在run中調用
     */
    private void thunderEnterAction() {
        /**
         *1.循環遍歷潛艇數組的每個對象並調用發射雷對象的方法接收返回雷對象
         *2.在循環中判斷接收的雷對象不為null
         *3.不為null則將thunders數組擴一個容量
         *4.將接收的雷對象賦值給 擴容後的位置
         */
        thunderEnterIndex++;//每隔10毫秒自增1次
        if (thunderEnterIndex % 100 == 0) {//每隔1000毫秒 (1s)執行一次生成雷的邏輯
            for (int i = 0; i < submarines.length; i++) {
                SeaObject obj = submarines[i].shootThunder(); //1.
                if (obj != null) { //2.
                    thunders = Arrays.copyOf(thunders, thunders.length + 1);//3.
                    thunders[thunders.length - 1] = obj;//4
                }
            }
        }
    }
```

#### 自動移動的相關實現

##### 潛艇,雷,炸彈自動移動

- ##### 重寫移動的具體邏輯。

  ```java
  所有潛艇類  step方法邏輯都是   x += speed;
  所有雷類    step方法邏輯都是   y -= speed;
  深水炸彈類  step方法邏輯都是   y += speed;
  ```

- ##### 自動移動方法在GameWorld類中寫   stepAction

  ```java
   /**
       * 自動移動的方法具體實現    -------在run中調用
       * 方法中循環遍歷潛艇數組,雷數組,炸彈數組的每個對象 並調用每個對象的step方法
       */
      private void stepAction() {
          //循環遍歷潛艇(submarines)數組並調用潛艇數組的每個對象的step方法
          for (int i = 0; i < submarines.length; i++) {
              submarines[i].step();
          }
          //循環遍歷雷(thunders)數組並調用潛艇數組的每個對象的step方法
          for (int i = 0; i < thunders.length; i++) {
              thunders[i].step();
          }
          //循環遍歷炸彈(bomb)數組並調用潛艇數組的每個對象的step方法
          for (int i = 0; i < bomb.length; i++) {
              bomb[i].step();
          }
      }
  ```

- ##### 將自動移動在run中調用

##### 需要手動生成對象,手動移動：

- ##### 需要手動生成：深水炸彈  ---當按下鍵盤的空格鍵產生

- ##### 需要手動移動：戰艦          ---當按下鍵盤的左右鍵,左右移動

##### 事件: 發生了一件事情                            (當按下鍵盤的空格鍵發射深水炸彈)

##### 事件處理:事情發生後要做的事情         (條件達成發射深水炸彈)

##### 事件偵聽：用來檢測事件處理的條件條件有沒有達成  (鍵盤偵聽器 實時偵聽鍵盤有沒有被響應)

##### Java提供了事件功能,提供鍵盤偵聽器功能

- ##### 在GameWorld類中導入鍵盤偵聽器和事件功能

  ```java
  import java.awt.event.KeyEvent;//鍵盤事件
  import java.awt.event.KeyAdapter;//鍵盤偵聽器
  ```

  

- ##### 在action方法中完成事件以及事件處理的邏輯工作,然後將事件處理交給鍵盤偵聽器來實時偵聽檢測

  ```java
     KeyAdapter adapter = new KeyAdapter() {//創建偵聽器對象
              @Override
              public void keyPressed(KeyEvent e) { //重寫偵聽當按下鍵盤的事件處理
                  //如何判斷用戶按下的是空格鍵？
                  //1.需要拿到當前用戶按下的鍵盤數據(碼)   e.getKeyCode()
                  //2.可以通過KeyEvent類名打點獲取對應鍵盤碼  KeyEvent.VK_SPACE
                  //判斷如果用戶按下碼 等於 空格鍵碼 處理對應邏輯
                   if(e.getKeyCode() == KeyEvent.VK_SPACE){
                       System.out.println("按下了鍵盤的空格鍵");
                   }
              }
          };
          addKeyListener(adapter);//將偵聽器對象添加到鍵盤檢測當中
  ```

#### 深水炸彈入場

- ##### 在戰艦類中寫一個生成深水炸彈對象的方法  shootBomb 

  ```java
   /**發射深水炸彈的方法 返回值為深水炸彈類型
       *
       */
      public Bomb shootBomb(){
          return new Bomb(x,y);//返回 一個深水炸彈對象
      }
  ```

- ##### 在GameWorld類中寫一個bombEnterAction ，深水炸彈入場的方法

  - ##### 通過戰艦對象調用發射深水炸彈的方法 接收炸彈對象

  - ##### 將炸彈數組擴1容量

  - ##### 將炸彈對象賦值給炸彈數組擴容後的位置

    ###### 注意：記得在paint方法中循環遍歷bomb數組並繪製

  ```java
   /**
       * 深水炸彈入場的方法    -----在當按下鍵盤的空格鍵的語句中調用
       */
      private void bombEnterAction() {
          /**-1.通過戰艦對象調用發射深水炸彈的方法 接收炸彈對象
           -  2.將炸彈數組擴1容量
           -  3.將炸彈對象賦值給炸彈數組擴容後的位置
           */
          Bomb obj = ship.shootBomb();//1.
          bomb = Arrays.copyOf(bomb, bomb.length + 1);//2.
          bomb[bomb.length - 1] = obj;//3.
      }
  ```

- ##### 在當按下了空格鍵的 if 語句中調用bombEnterAction 

  ```java
   private void action() {//普通方法
          KeyAdapter adapter = new KeyAdapter() {//創建偵聽器對象
              @Override
              public void keyPressed(KeyEvent e) {
                  //重寫偵聽當按下鍵盤的事件處理
                  //如何判斷用戶按下的是空格鍵？
                  //1.需要拿到當前用戶按下的鍵盤數據(碼)   e.getKeyCode()
                  //2.可以通過KeyEvent類名打點獲取對應鍵盤碼  KeyEvent.VK_SPACE
                  //判斷如果用戶按下碼 等於 空格鍵碼 處理對應邏輯
                  if (e.getKeyCode() == KeyEvent.VK_SPACE) {
                      bombEnterAction();//調用深水炸彈入場的方法
                  }
              }
          };
          addKeyListener(adapter);//將偵聽器對象添加到鍵盤檢測當中
   }
  ```

  ##### 戰艦移動通過按下鍵盤的左右鍵實現

  - ##### 戰艦類中提供兩個移動的方法

    ```java
      public void moveLeft(){ //左移方法
            x -= speed;
        }
        public void moveRight(){//右移方法
            x += speed;
        }
    ```

  - ##### 在當按下鍵盤的左鍵 或右鍵的代碼中分别調用對應的移動

    ```java
     if (e.getKeyCode() == KeyEvent.VK_SPACE) {
                        bombEnterAction();//調用深水炸彈入場的方法
                    }else if(e.getKeyCode() == KeyEvent.VK_LEFT){//判斷用戶按下的是否是左鍵
                         ship.moveLeft();//左移動
                    }else if(e.getKeyCode() == KeyEvent.VK_RIGHT){//判斷用戶按下的是否是右鍵
                         ship.moveRight();//右移動
                    }
    ```

##### 問題：所有潛艇、雷、炸彈 虽然移出畫面外,實際還存在於内存中。

```java
400 毫秒   1個潛艇對象
1秒        2個潛艇對象 +  2個雷對象    ----4個對象
1分钟      240個對象
10分钟     2400個對象
----------------------------------------------------
10毫秒    移動方法至少要遍歷2400個對象  paint方法中至少要遍歷2400個對象   -----遍歷4800個對象
1秒       .......    
```

##### 内存泄漏：指的是不斷在内存中產生新對象

##### 内存溢出：指的是内存沒有空間可用 ---程序異常終止

##### GC：垃圾回收器,不定時的清理内存垃圾(當對象沒有被引用時)。

##### 優化越界的對象

- ##### 可参與優化的對象：潛艇的對象， 雷的對象 ,   深水炸彈的對象

  - ##### 上述的每個對象移動的方向不一樣,處理的越界標準不一樣,但是都需要定義一個越界的標準方法。因為共6個子類需要判斷越界的方法,其中3個子類的判斷越界標準是一樣的,所有也可以做成普通方法,3個潛艇類複用父類中提供的越界判斷標準,剩下3個子類可以自行進行重寫越界標準。

  ```java
   /** 越界判斷標準的方法
       * 因為三個潛艇類是共用一個邏輯實現,所有可以定義為普通方法。
       *        剩下：炸彈類,魚雷類,水雷類自行進行重寫該方法實現越界標準。
       */
      public boolean isOutBounds(){
          return this.x >= GameWorld.WIDTH;//潛艇的越界標準
      }
  深水炸彈類重寫：
       @Override
      public boolean isOutBounds() {
          return this.y >= GameWorld.HEIGHT;//深水炸彈的越界標準
      }
  水雷類重寫：
     @Override
      public boolean isOutBounds() {
          return this.y <= 150 - height;//水雷的越界標準
      }
  魚雷類重寫：    
       @Override
      public boolean isOutBounds() {
          return this.y <= -height;//魚雷的越界標準
      }
  ```

- ##### 在GameWorld類定義一個删除越界對象的方法   deleteOutBounds

  - ##### 循環遍歷潛艇數組的每個對象,並調用每個對象的isOutBounds方法。if( submarines[i].isOutBounds)

  - ##### 如果為true,將數組中最後一個對象賦值給當前越界對象進行覆蓋。

  - ##### 實現縮容,删除一個容量即可

  ```java
     /**
       * 删除越界對象的具體實現方法    ------在run中調用
       */
      private void deleteOfBounds() {
          /**-1.循環遍歷潛艇數組的每個對象,並調用每個對象的isOutBounds方法。if( submarines[i].isOutBounds)
           - 如果為true,將數組中最後一個對象賦值给當前越界對象進行覆蓋。
           - 實現縮容,删除一個容量即可
           */
          for (int i = 0; i < submarines.length; i++) {
              if (submarines[i].isOutBounds()) {//如果if為true  則表示submarines[i]這個對象越界了。
                  submarines[i] = submarines[submarines.length - 1];//覆蓋越界對象
                  submarines = Arrays.copyOf(submarines, submarines.length - 1);//縮容
              }
          }
          /**-2.循環遍歷雷數組的每個對象,並調用每個對象的isOutBounds方法。if( thunders[i].isOutBounds)
           - 如果為true,將數組中最後一個對象賦值给當前越界對象進行覆蓋。
           - 實現縮容,删除一個容量即可
           */
          for (int i = 0; i < thunders.length; i++) {
              if (thunders[i].isOutBounds()) {
                  thunders[i] = thunders[thunders.length - 1];
                  thunders = Arrays.copyOf(thunders, thunders.length - 1);
              }
          }
          /**-3.循環遍歷炸彈數組的每個對象,並調用每個對象的isOutBounds方法。if( bomb[i].isOutBounds)
           - 如果為true,將數組中最後一個對象賦值给當前越界對象進行覆蓋。
           - 實現縮容,删除一個容量即可
           */
          for (int i = 0; i < bomb.length; i++) {
              if (bomb[i].isOutBounds()) {
                  bomb[i] = bomb[bomb.length - 1];
                  bomb = Arrays.copyOf(bomb, bomb.length - 1);
              }
          }
      }
  ```

- ##### 在run中調用删除越界對象的方法

  ```java
  TimerTask task = new TimerTask() { //創建任務子類 在子類重寫run方法 部署具體的任務邏輯
              @Override
              public void run() { //具體要自動執行的任務方法
                  submarineEnterAction();//調用潛艇入場的方法
                  thunderEnterAction();//調用雷入場的方法
                  stepAction();//調用移動的方法
                  deleteOfBounds();//調用自動删除越界對象的方法
                  System.out.println("雷的數量 :" + thunders.length+",  炸彈的數量:"+bomb.length);
                  repaint(); //重新執行一次paint方法
              }
          };
  ```

------

#### 項目後續的交互邏輯

- ##### 碰撞交互邏輯的實現

  - ##### 深水炸彈碰到潛艇時,會有不同的邏輯交互：

    - ##### 深水炸彈打到偵察潛艇 +10分  , 魚雷潛艇 + 40分

    - ##### 深水炸彈打到水雷潛艇 +1命

  - ##### 魚雷或水雷碰到潛艇,則扣1命

### 接口

##### 定義：接口是一組行為的規范,接口不關心類之間是否是一種的關係,只關心多個類之間的行為是否是一致的！

##### 一個類是可以實現多個接口,所以接口可以多實現.

##### 接口定義時,要求盡可能小而精,不要大而全的接口。

- ##### 接口是一個數據類型   (引用類型)

- ##### 接口定義是通過interface關鍵字定義

- ##### 接口中只能包含常量和抽象方法                      jdk1.8以後支持默認方法,静態方法

- ##### 接口是抽象的 不能被創建對象,接口中的行為必須要由實現類來實現。

- ##### 一個類要實現接口 需要通過implements關鍵字實現    :  類名  implements   接口名即可

- ##### 實現類實現接口,必須要重寫實現該接口中所有的抽象方法. 

  - ##### 快捷重寫接口方法  選中報錯行 -- alt+Enter  + Enter + Enter

- ##### 接口之間是可以實現繼承的，例如：B接口  extends A接口

  - ##### 注意：若有實現類C implements B接口 ,那麼實現類C也需要將B接口中繼承得來的抽象内容一並實現.

- ##### 實現類又要繼承又要實現,語法：先繼承 後實現     例如:  類   extends 類   implements 接口

  ```java
  類别之間的關係：
      類   與 類之間   ----繼承關係
      接口  與 接口之間 ----繼承關係
      類    與 接口之間 ----實現關係
  ```

  ```java
  class Aoo{ //類的定義  ---引用類型 
  }
  
  interface Inter{//接口的定義  ---引用類型
  }
  ```

  ```java
  package oo.day05;
  /**
   * 接口的使用演示類：
   */
  public class InterfaceDemo {
      public static void main(String[] args) {
          //Inter1 i1 = new Inter1();//接口是抽象的 不能被創建對象
      }
  }
  interface Inter1{//接口的定義
      //接口中默認常量  默認公開權限
      public static final int NUM = 10000;//常量的定義
      int NUM2 = 1;
      //默認抽象方法
      public abstract void test();
      void test2();//抽象方法
  }
  interface Inter2{
      void fun();
  }
  interface Inter3 extends Inter2{//接口之間是可以實現繼承關係
      void fun2();
  }
  class SuperDemo{//父類
  }			  //先繼承        後實現
  class Aoo extends SuperDemo implements Inter1,Inter3 { //快捷重寫接口方法  選中報錯行 -- alt+Enter  + Enter + Enter
      @Override
      public void test() {
      }
      @Override
      public void test2() {
      }
      @Override
      public void fun() {
      }
      @Override
      public void fun2() {
      }
  }
  ```

#### 抽象類和接口的區别：

- 語法層面：
  - 抽象類有構造方法        |     接口沒有構造方法
  - 抽象類可以放普通成員/抽象成員   |   接口中只能放常量,抽象方法   JDK1.8 静態方法,默認方法
  - 抽象類成員可以選擇訪問修飾符     |  接口中成員只能是public
  - 類只能 單繼承               |     接口可以多繼承多實現
- 設計層面:
  - 類的封裝：同一類别下多個對象存在共有屬性和行為,提取到類模板中
    - 目的：為了批量產生多個對象
  - 類的繼承:   多個類之間存在一個共有屬性和行為,且概念是一致的,提取到父類實現繼承
    - 目的:  1.優化冗余代碼,實現複用  2.可以向上造型管理子類實現調用父執行子
    - 缺點:  耦合度較高.父類中的代碼直接或間接影響子類！
  - 接口使用:  接口只代表一種行為,如果多個類之間只是行為存在共性時沒有數據使用時,優先選擇接口.
    - 目的：1.可以向上造型管理子類實現調用父執行子  2.可以多實現擴展性強

##### 在項目包下創建了兩個接口,EnemyScore和EnemyLife

```java
/**
 * 加分的接口
 *          偵察潛艇 ,魚雷潛艇實現
 */
public interface EnemyScore {

    int getScore(); //提供加分的行為
}
-----偵察潛艇類  魚雷潛艇類分别實現該接口
      @Override
    public int getScore() {偵察潛艇類
        return 10;
    }
      @Override
    public int getScore() {魚雷潛艇類
        return 40;
    }
----------------------------
   /**
 * 加命的接口
 *          水雷潛艇實現
 */
public interface EnemyLife {

    int getLife();//提供加命的行為
}

    @Override			水雷潛艇實現
    public int getLife() {
        return 1;
    }
```

#### 錯誤分類:

- ##### 編譯錯誤:編譯期間產生的錯誤  ------------->幾乎都是語法的錯誤(代碼不熟,練的少)

- ##### 運行錯誤:運行期間產生的錯誤  ------------->

  - ##### 空指針異常：NullPointException  （通過null值打點訪問造成）

  - ##### 數組訪問越界異常：ArrayIndexOfBoundsException(下標訪問给錯造成)	

- ##### 無錯誤邏輯異常：

  - ##### 縮小並縮定代碼出錯的範圍 (根據現象來縮定)

  - ##### 可以通過打桩的方式來測試

- #### 多態

  ##### 人類在睡觉的行為上實現多態:右側睡 ,左側睡 ,躺著睡.

  ##### 在程序中的多態指的是父類的行為在子類中有不同的實現

```java
人  r1 = new 理髮師();//向上造型 聲明父 new子對象
人  r2 = new 醫生();
人  r3 = new 園丁();
r1.cut();//編譯期間調用父  運行時執行理發師的cut行為 
r2.cut();//編譯期間調用父  運行時執行醫生的cut行為 
r3.cut();//編譯期間調用父  運行時執行園丁的cut行為 
abstract class 人{
    abstract void cut();
}
class 理發師 extends 人{
    void cut(){
        sout("剪髮");
    }
}
class 醫生 extends 人{
    void cut(){
        sout("手術");
    }
}
class 園丁 extends 人{
    void cut(){
        sout("剪草");
    }
}
```

當一個對象被造型為不同的接口類型時,具有不同的行為。

```java
我 me = new 我();
me.授課();
me.卷();

講師  j = new 我();  //向上造型
j.授課();

其它老師同事 q = new 我();//向上造型
q.卷();
interface 講師{
   void 授課();
}

interface 其它老師的同事{
    void 卷();
}

class 我  implments 講師,其它老師同事{
    授課(){ }
    卷(){  }
}
```

##### 向上造型/引用類型中的自動類型轉換

- ##### 父 大 子 小  ----------------聲明父類型  new 子對象

- ##### 能夠向上造型    例如：  父 new  子       接口  new 實現類

##### 向下轉型/引用類型中強製類型轉換

- ##### 能否強轉成功,要看下面兩個條件

  - ##### 1.要強轉的引用類型變量中的對象 就是要轉換的這個類型

  - ##### 2.要強轉的引用類型變量中的對象 實現了要轉換的接口類型

    - ###### 子類或實現類之間 是無法互相轉換的.

    - ###### 在引用類型轉換的工作之前,應該使用instanceof 關鍵字 判斷是否可以強轉成功

```java
main{
 	 Aoo a1 = new Boo();//向上造型的語法    
     Boo b1 = (Boo)a1;//可以強轉成功 符合條件1
     Inter1 i1 = (Inter1)a1;//可以轉換成功 符合條件2
     Coo c1 = (Coo)a1;//運行時異常： class cast Exception  類型轉換異常
}
class Aoo{//父類
    
}
interface Inter1{
    
}
class Boo extends Aoo implements Inter1{
    
}
class Coo extends Aoo{
    
}
---------
    package oo.day06;

/**
 * 類型轉換的演示類：
 */
public class ClassCastDemo {
    public static void main(String[] args) {
        Aoo a1 = new Boo();//向上造型的語法
        if(a1 instanceof Boo){ //如果a1 是 Boo這個類型
            Boo b1 = (Boo)a1;//可以強轉成功 符合條件1
            System.out.println("轉換Boo成功");
        }
        if(a1 instanceof Inter1){//如果a1 實現 Inter1 接口
            Inter1 i1 = (Inter1)a1;//可以轉換成功 符合條件2
            System.out.println("轉換Inter1成功");
        }
        if(a1 instanceof Coo){ //如果a1 是 Coo類型
            Coo c1 = (Coo)a1;//運行時異常： class cast Exception  類型轉換異常
        }else {
            System.out.println("轉換Coo失敗");
        }
        //其它代碼....
    }
}
class Aoo{//父類

}
interface Inter1{

}
class Boo extends Aoo implements Inter1{

}
class Coo extends Aoo{

}
```

##### 碰撞的邏輯實現:

- ##### 深水炸彈與 各種潛艇碰撞

- ##### 魚雷 水雷與 戰艦碰撞

  - ##### 碰撞的邏輯是相同的,只是碰撞的對象不同而已

  - ##### 因為7個子類都需要碰撞檢測的行為,所以可以放在父類中,因為碰撞的邏輯是一樣的,所以做成普通方法

```java
public boolean isHit(SeaObject other){
    this  表示當前調用方法的對象
    other 表示傳遞参與碰撞的對象
    int x1 = this.x - other.width;
    int x2 = this.x + this.width;
    int y1 = this.y - other.height;
    int y2 = this.y + this.height;
    int x = other.x;
    int y = other.y;
    return (x >= x1 && x <= x2) && (y >= y1 && y <= y2);        
}
1)潛艇對象.isHit(深水炸彈);------------- this指代的是潛艇對象     other指代的是深水炸彈對象
2)深水炸彈.isHit(潛艇對象);------------- this指代的是深水炸彈對象  other指代的是潛艇對象
3)雷對象.isHit(戰艦);	-------------  this指代的是雷對象       other指代的是戰艦對象
4)戰艦.isHit(雷對象);	-------------  this指代的是戰艦對象      other指代的是雷對象
```

##### 碰撞檢測的行為是自動發生

- ##### 實現炸彈與潛艇的碰撞

  - ##### 1.在GameWorld類中寫一個bombBangAction

    ```java
      /**
         * 炸彈與潛艇碰撞的具體實現方法 ------在run中調用
         */
        private void bombBangAction() {
            for (int i = 0; i < bomb.length; i++) {//控製輪數的循環
                Bomb b = bomb[i];//獲取當前輪的炸彈對象
                for (int j = 0; j < submarines.length; j++) {//控製次數的循環
                    if (b.isHit(submarines[j])) {//拿當前輪的炸彈對象依次與潛艇數組的每個對象去進行碰撞檢測。
                        b.goDead();//將炸彈對象標記為死亡狀態
                        submarines[j].goDead();//將當前潛艇對象標記為死亡狀態
                    }
                }
           }
    
        }
    ```

  - ##### 2.在run中調用bombBangAction

- ##### 炸彈打到潛艇兩個都需要消失,當對象被標記為死亡狀態,則不再進行繪製,可以在SeaObject類中做一個goDead方法,讓需要被標記為死亡狀態的對象調用。

  ```java
  /**
       * 判斷當前對象是否是死亡的狀態的方法
       */
      public boolean isDead() {
          return currentStatus == DEAD;
      }
  ```

  ##### 深水炸彈碰到潛艇時,會有不同的邏輯交互：

  - ##### 深水炸彈打到偵察潛艇 +10分  , 魚雷潛艇 + 40分

  - ##### 深水炸彈打到水雷潛艇 +1命

    - ##### 1.先將畫面中的分數和命數繪製出來。

    - ##### 2.在炸彈碰到潛艇的邏輯代碼中：

      ```java
       //submarines 是SeaObject 數組
                          //面向對象原則-依賴倒置原則:實現编碼過程中,盡可能依賴抽象的而非實現的,代碼才可具有可擴展性。
                          if (submarines[j] instanceof EnemyScore) {//如果當前這個潛艇對象 實現了 加分的接口
                              EnemyScore obj = (EnemyScore) submarines[j];//把潛艇對象的類型 轉換接口類型
                              score += obj.getScore();//編譯期調用父 運行時執行子
                          }else if(submarines[j] instanceof EnemyLife){//如果當前這個潛艇對象 實現了 加命的接口
                              EnemyLife obj = (EnemyLife) submarines[j];//把潛艇對象的類型 轉換接口類型
                              ship.setLife( obj.getLife());//編譯期調用父 運行時執行子
                          }
      ```

- ##### 雷與戰艦的碰撞

  - ##### 1.在GameWorld類中寫一個thunderBangAction   (雷與戰艦碰撞的實現)

    ```java
      /**
         * 雷與戰艦具體實現碰撞檢測代碼
         */
        private void thunderBangAction() {
            for (int i = 0; i < thunders.length; i++) {
                if (thunders[i].isHit(ship)) {//依次將雷數組中每個對象與戰艦對象進行碰撞檢測
                    thunders[i].goDead();//將當前撞到戰艦的雷對象 標記為死亡狀態
                    ship.subtractLife();//扣減生命
                }
            }
        }
    ```

  - **2.在run中調用thunderBangAction**

#### 游戲狀態

- ##### 游戲開始狀態: 當運行程序後,應該有一個開始界面,但按下空格鍵切換運行狀態

- ##### 游戲運行狀態: 潛艇,雷自動生成,移動,與戰艦交互,操作鍵盤等.  當戰艦命數為0 切換游戲结束狀態

- ##### 游戲结束狀態: 繪製结束的界面,畫面交互邏輯等暫停。

##### 在GameWorld類中定義3個常量  1 個變量

```java
    public static final int GAME_START = 0;//開始狀態
    public static final int GAME_RUNNING = 1;//運行狀態
    public static final int GAME_OVER = 2;//结束狀態

    public int currentGameStatus = GAME_START;//默認是游戲開始狀態
```

**在GameWorld類的paint方法中根據不同的狀態繪製不同的邏輯**

```java
 @Override
    public void paint(Graphics g) { //系統提供的繪製方法   g---畫筆
        switch (currentGameStatus){
            case GAME_START:
                ImageResource.start.paintIcon(null,g,0,0);
                break;
            case GAME_RUNNING:
                ImageResource.sea.paintIcon(null, g, 0, 0);
                ship.paintImage(g);
                for (int i = 0; i < thunders.length; i++) {
                    thunders[i].paintImage(g);
                }
                for (int i = 0; i < submarines.length; i++) {
                    submarines[i].paintImage(g);
                }
                for (int i = 0; i < bomb.length; i++) {
                    bomb[i].paintImage(g);
                }
                g.setFont(new Font("", Font.BOLD, 20));//設置字體的風格,大小
                g.drawString("SCORE: " + score, 200, 50);//分數的繪製
                g.drawString("LIFE: " + ship.getLife(), 400, 50);//命數的繪製
                break;
            case GAME_OVER:
                ImageResource.gameover.paintIcon(null,g,0,0);
                break;
        }
```

**開始狀態當按下空格鍵時切換運行狀態：**

```java
 			if (e.getKeyCode() == KeyEvent.VK_SPACE) {
                    if (currentGameStatus == GAME_START) {//判斷當前狀態是否是游戲開始狀態
                        currentGameStatus = GAME_RUNNING;//切換為運行狀態
                    } else {
                        bombEnterAction();//調用深水炸彈入場的方法
                    }
                } 
```

**運行狀態下進行交互：**

```java
 			if (currentGameStatus == GAME_RUNNING) { //如果當前游戲狀態是運行狀態
                    submarineEnterAction();//調用潛艇入場的方法
                    thunderEnterAction();//調用雷入場的方法
                    stepAction();//調用移動的方法
                    bombBangAction();//調用炸彈與潛艇碰撞檢測方法
                    thunderBangAction();//調用雷與戰艦碰撞檢測的方法
                    deleteOfBounds();//調用自動删除越界對象的方法
                    repaint(); //重新執行一次paint方法
                }
```

##### 可以自己根據狀態擴展的内容：

- ##### 增加暫停狀態:在游戲運行狀態中可以暫停游戲,再次按下按鍵則切換繼續游戲。

  ```java
  if (e.getKeyCode() == KeyEvent.VK_P) {//判斷用戶按下是否是P鍵
                      if (currentGameStatus == GAME_RUNNING) {//如果游戲是運行狀態
                          currentGameStatus = GAME_PAUSE; //切換暫停
                      } else if (currentGameStatus == GAME_PAUSE) {//如果是暫停狀態
                          currentGameStatus = GAME_RUNNING;//切換運行
                      }
                  }
  ```

- ##### 戰艦不要移出畫面外

1. ##### 聽不懂我在講什麼  -------落課  

2. ##### 暈乎乎的,能理解啥意思 -----     正常

3. ##### 大概聽懂了,但是讓設計設計不出來  -----優秀



### 複習回顧

#### 基礎語法：

- ##### 聲明變量會不會?  成員變量？     局部變量?

- ##### 數據類型是什麼?  數據有哪些?  常用：int  long   double    char   boolean

- ##### 運算符

  - ##### 數學運算符     +   -   *   /    %

  - ##### 自增自減運算符  

    - ##### 参與運算  符號在前,先去進行自增自減操作  符號在後,先去做其它運算,再進行自增自減..

  - ##### 關係運算符   >    <    >=       <=      ==     !=       结果是boolean類型

  - ##### 邏輯運算符  

    - ##### 	邏輯與(&&): 表示並且的意思,兩個或多個條件都必須成立,结果才成立: 見fasle 即fasle

      - ##### 短路與現象：判斷條件過程中,如果前面的條件不成立,直接false

    - #####     邏輯或(||): 表示或者的意思,兩個或多個條件有一個成立,结果就成立:  見true 即 false

      - ##### 短路或現象：判斷條件過程中,如果前面的條件成立, 直接返回true

    - #####     邏輯非(!) ：表示结果取反的意思   非真即假   非假即真

  - ##### 擴展賦值運算符

    - ##### 作用於變量自身基礎上運算,並將结果賦值给自身

    - ##### 符號：+=    -=    *=    /=    %=

  - ##### 三元表達式

    - #####  判斷的邏輯 ?  判斷邏輯為true值位置  ：判斷的邏輯為fasle值位置

    - ##### int a = 10;  int b = 20;       int max =  a > b ?  a : b;

  - ##### 字符串拼接符

    - ##### String類型,可以儲存字符串.    String name = "哈嘍";

    - ##### 使用+號時,如果有一方是字符串類型,都可進行拼接操作.   "2"  +  1   ---- >"21" 

- #### 程序结構

  - ##### 順序结構:代碼順序執行,每句代碼都執行.

  - ##### 分支结構:有條件執行某個語句.

    - ##### 單路分支:當對一個數據有一個判定條件時,滿足則執行某個語句.

      ```java
      if(條件){ 執行的代碼 }
      ```

    - ##### 雙路分支:當對一個數據有一個判定條件時,滿足則執行某個語句,不滿足則會執行某個語句

      ```java
      if(條件){ 執行的代碼 } else { 執行的代碼 } 
      ```

    - ##### 多路分支:當對一個數據由多種判定條件時,存在關聯關係,當滿足一個判斷時,其它則不執行.

      ```java
      if(條件1){}  else if(條件2){  } else if(條件3){  }
      ```

      - ##### switch  结構：只能對數據進行判等操作。

  - ##### 循環结構:有條件循環執行某個語句

    - ##### while：先判斷條件,再决定是否執行循環體,有可能一次都不執行

      ```java
      while(循環條件){ 循環體 }
      ```

    - ##### do while: 先做一次循環體,再判斷條件决定是否執行,至少執行一次。

      ```java
      do { 循環體  } while(循環條件);
      ```

      - ##### 當已知循環條件未知次數時,通常選擇的循環.

    - ##### for:當已知次數時使用。

      ```java
      for( ){  }
      ```

- #### 數組

  - ##### 特點：用來存放同一類型的多個數據元素的集合.	數組長度一旦確定是固定的。

  - ##### 數組使用前需要初始化,開闢數組對象空間 ,確定容量.

  - ##### 數組訪問,賦值或者是獲取都是從下標0代表數組第一塊空間.

  - ##### 數組屬性： 數組名.length 可以獲取該數組的長度：從1開始算. 		  

- #### 方法

  - ##### 作用：當出現局部代碼某些邏輯冗余重複,可以使用方法來進行封裝複用.實現一次定義多次使用.

  - ##### 無参無返回值: 只是為了包裹一段功能性代碼,不需要外部傳入數據,也不需要返回數據.

  - ##### 有参無返回值: 需要外部傳遞數據,進行一些邏輯運算,能讓方法功能正常執行。

  - ##### 無参有返回值: 方法内部運算處理邏輯後,需要返回運算结果。

  - ##### 有参有返回值: 需要外部傳遞數據,並返回運算结果

  - ##### 方法重載：當做多個方法,具有同一個功能含義時,可能由於参數個數或参數類型不同導致的多個方法

    - ##### 可以做成方法的重載,用一個同一個方法名來代表這些方法。目的為了方便調用。

#### 面向對象

- ##### 封裝

  - ##### 屬性的封裝：屬性私有化,方法公開化   ---目的：保護程序數據的合法性.

  - ##### 方法的封裝：將冗余重複的代碼封裝到一個方法中--目的：一次定義多次使用

  - ##### 類的封裝：一個類别下多個對象存在共有的屬性和行為,可以封裝到模板類中--目的:批量產生對象

- ##### 繼承: 多個模板類之間存在共有的屬性和行為,且概念上是is a的關係。可以通過繼承解决

  - ##### 繼承是概念上的代表

  - ##### 模板之間的冗余問題。找一個父類帶代表這些冗余的數據和行為。

  - ##### 可以通過繼承關係實現向上造型。可以通過父類來管理不同的子對象,調用父執行子。

  ##### 接口：行為上的代表

  ##### 可以通過實現接口關係實現向上造型。可以通過父類來管理不同的子對象,調用父執行子。

- ##### 多態

  - ##### 一個父類中的行為 子類有不同的實現

  - ##### 多態語法：聲明父  new子

  - ##### 向上造型                向下轉型

------

### API

> ##### API（application Programing Interface）：應用程序接口(功能)
>
> 作用：為了讓使用者更好的實現需求,設計者將該功能的複雜業務邏輯進行封裝成一個個的API.我們只需要只要功能的作用以及如何使用功能.

##### Java提供的一些功能分别在不同包下:

- ##### Java.lang 包 ：核心語言包,不需要導入直接使用例如： String, System , Object ,包裝類...

- ##### java.io 包 ：提供文件輸入輸出的内容.

- ##### java.net 包：提供網络相關功能.

- ##### java.uitl 包：常用工具包.

--------

#### String

- ##### String是引用類型,該類被final修飾,不可被繼承

- ##### String類型本質上用char數組來進行儲存的,char數組被final修飾的,意味一個字符串對象被創建後是不可修改的！

- ##### String對象一旦被創建了不可變,如果修改了 那就是產生了新的字符串對象.

- ##### String的不可變性：原因,因為String非常常用,設計者為了優化内存,在内存中還存在字符串常量池 ,常量池主要存放已創建過的字符串對象,如果程序在創建已经創建過的字符串對象時,則直接實現複用。

  - ###### 程序現象：當創建字符串時,會先去常量池中查找有沒有可用的字符串,如果有直接複用地址.

```java
String a = "ABC";

char[] b = {'A','B','C'};
----------------------------------
      //查看類源碼： ctrl + 鼠標左鍵
        String a = "123";
        String b = a;
        System.out.println( a == b);
        a += "456";
        System.out.println(a);//123456
        System.out.println(b);//123
        System.out.println( a == b);//如果是引用類型變量使用雙等判斷,則判斷是兩個變量中的地址是否相同！

        int c1 = 10;
        int c2 = 10;
        System.out.println(c1 == c2);//如果是基本類型變量使用雙等判斷,則判斷是兩個變量中的數據是否相同！
```

##### String創建對象的方式

- ##### 静態初始化(可以複用)

  - ##### 以字符串字面量的形式創建的字符串對象			 例如：String a = "ABC";

  - ##### 字符串常量		static final  String b = "ABC";

  - ##### 以字符串字面量拼接而成的字符串       String c = "A" + "BC";

    ```java
    static final String c = "ABC";
    		String a = "ABC";
            String a1 = "ABC";
            String b = "A" + "BC";
            System.out.println(a == a1);//true 可複用
            System.out.println(a == b);//true  可複用
            System.out.println(a == c);//true  可複用  
    ```

- ##### 動態初始化(不推薦寫法)

  - ##### 以new 關鍵字 創建的String對象   		例如： String d = new String("ABC");

  - ##### 以字符串變量的形式拼接而成String對象  

    ```java
    		//動態初始化  不推薦不可複用
            String d = new String("ABC");
            System.out.println(a == d);//false 不可複用
            String e  = "A";
            e += "BC";
            System.out.println(a == e);//false 不可複用
    ```

  ##### 面試題  ：  String d = new String("ABC");

  ##### 問：上述代碼創建了幾個String對象

  ##### 答：創建了兩個String對象  

  ------

####       StringAPI

- ##### String類中提供了一些比較常用的功能,我們可能通過這些功能 獲取字符串的長度,可以通過给定下標獲取對應的字符,也可以檢索字符串中有沒有存在给定的内容..

  - ##### length();  獲取當前字符串對象的長度

  - **charAt();  可以根據给定的下標返回對應的字符内容**

  ```java
    	String str = "Thinking in Java是一本好書";
          int len = str.length();//獲取str這個字符串對象的長度
          System.out.println(len);//21
          char temp = str.charAt(len - 1);//根據给定的下標獲取對應的字符
          System.out.println(temp);//書
          //面試題：請编寫一段程序,將上面str對象中存在i的次數打印輸出
          int count = 0;
          for (int i = 0; i < str.length(); i++) {
              if(str.charAt(i) == 'i'){ //判斷當前循環的字符 是否是 i
                  count++;//累加
              }
          }
          System.out.println(count);
  ```

  - ##### indexOf();  從頭到尾檢索傳入字符|字符串内容,檢索到立刻返回對應下標。

  - **lastIndexOf();從尾到頭檢索傳入字符|字符串内容,檢索到立刻返回對應下標。**

  ```java
    String str = "Thinking in Java是一本好書";
    int index = str.indexOf('i');
    index = str.indexOf("Java");//根據给定的字符或字符串 從頭檢索,檢索到立刻返回對應的下標
    System.out.println(index);
    index = str.indexOf('i', 3);//第二個参數可以指定開始檢索的下標進行檢索
    System.out.println(index);
  ```

  - **字符串去除兩端空白, 可以轉換字符串英文大小寫切換,判定是否以..開頭 或以...内容结尾的方法。**

  ```java
  	    String str = "Thinking in Java是一本好書";
          str = str.toUpperCase();//轉換英文大寫
          System.out.println(str);
          str = str.toLowerCase();//轉換英文小寫
          System.out.println(str);
          str = " Tom";
          System.out.println(str);
          str = str.trim();//去除字符串兩端空白
          System.out.println(str);
          System.out.println(str.startsWith("T"));// 判斷是否以T開頭
          System.out.println(str.endsWith(" "));//判斷是否以空格结尾
  ```

  - **字符串截取功能,  將值類型轉換為String類型** 

  ```java
    String mail = "bjzhangpeng@teud.cn";
          mail= mail.substring(0,11);//substring截取包頭不包尾   1.開始截取的下標  2.结束截取的下標(不包含)
          System.out.println(mail);
          // liucs@tedu.cn  如何做一個通用的截取用戶名的方式。
          mail = "liucs@tedu.cn";
          String user = mail.substring(0,mail.indexOf("@"));//1.開始下標0  2.根據檢索到的@ 字符當作截取结束位置.
          System.out.println(user);
          //可以通過给定長度的方式進行截取
          user = mail.substring(0,0+5);//1.開始截取的下標  2.基於開始下標截取的長度
          System.out.println(user);
  
          int a = 1000;
          String str1 = String.valueOf(a);//將傳入的類型數據 轉換為String對象類型儲存
          System.out.println(str1);
  
          System.out.println(10000);//打印的内容 本質上都是轉換為String後再進行顯示。
  ```

  - **判斷字符串中是否包含某個字符串内容 , 判斷字符串長度是否為0,將字符串轉換為char數組**

  ```java
      /** contains();   isEmpty();    toCharArray();
           *         String str = "Thinking in Java是一本好書";
           *         System.out.println(str.contains("一本好書")); //判斷str中是否包含 一本好書  内容
           *         str = "";
           *         System.out.println(str.isEmpty());//判斷當前str對象中的字符串長度是否為0的方法
           *         // if(str == null)  判斷當前str是否為null
           *         str = "123456789";
           *         char[] tempArr= str.toCharArray();//將str中字符串内容轉換為以char數組的形式返回
           *         for (int i = 0; i < tempArr.length; i++) {
           *             System.out.println(tempArr[i]);
           *         }
           */
  ```

  ```java
  //面試題：
          /** 已知  String str = "上海自來水來自海上";
           *     請寫一段程序,判斷 str 對象中的内容是否是回文數.
           *     思路：1.拿第一字符 與最後一次字符判斷是否相等,再拿第二個字符與倒數第二個字符判斷是否相等......
           *          2.比較的次數 就是長度/2
           *          3.在比較的過程中,如果不相等,直接判定不是回文數,不需要繼續比較了..
           */
          String str = "上海自來水來自h上";
          boolean temp = true;//默認是回文數
          for (int i = 0; i < str.length() / 2; i++) {
              if (str.charAt(i) != str.charAt(str.length() - 1 - i)) {//如果當前比較的字符 不等於 後面對應的字符
                  temp = false;//將temp 重置為false
                  break;//退出循環
  //                System.out.println("不是回文數");
  //                return;//退出當前方法
              }
          }
  //        System.out.println("是回文數");
          System.out.println("是否是回文數 : " + temp);
          /**
           *   已知 String str = "1.永遠熱情2.永遠年輕3.永遠熱淚盈眶4.永遠在路上";
           *   需求：將當前字符串中數值的數據進行累加和並打印輸出.
           *   思路：String中每個字符 本質上都是字符碼
           *      "0"   ----碼  48  - 48  = 0
           *      "1"   ----碼  49  - 48  = 1
           *      "2"   ----碼  50  - 48  = 2
           *      "3"   ----碼  51
           *      "4"   ----碼  52
           *      "5"   ----碼  53
           *      "6"   ----碼  54
           *      "7"   ----碼  55
           *      "8"   ----碼  56
           *      "9"   ----碼  57
           *       1.循環遍歷當前字符串中的每個字符
           *       2.判斷當前字符 是否 >= '0' 並且 當前字符 是否 <= '9'
           *       3.如果條件成立 說明當前字符是數值  可以將這個當前字符 - 48  累加該值
           */
          String str1 = "1.永遠熱情2.永遠年輕3.永遠熱淚盈眶4.永遠在路上";
          int sum = 0;//記錄和
          for (int i = 0; i < str1.length(); i++) {
              if (str1.charAt(i) >= '0' && str1.charAt(i) <= '9') {//判斷當前字符 是否 >= '0' 並且 當前字符 是否 <= '9'
                  sum += str1.charAt(i) - 48;//說明當前字符是數值  可以將這個當前字符 - 48  並累加該值
              }
          }
          System.out.println(sum);//打印和
  ```

##### String是不可變性,String如果修改就是意味著在内存中產生新的對象,對内存的消耗非常大,很有可能會出現outOfMemoryError的情况:内存溢出錯誤！

#### StringBuilder

##### 適用性：如果對String進行頻繁修改的話,推薦使用StringBuilder來完成拼接工作.因為StringBuilder维護了可變的char數組,修改性能小,而且提供了很多對字符串操作的功能。

- ##### 增,删,改,插,反轉功能等..

  ```java
   		String str = "好好學習Java";
          StringBuilder builder = new StringBuilder(str);//創建StringBuilder對象傳入需要修改的字符串副本.
          System.out.println(builder);
          //追加方法：在小括號中傳遞需要追加的内容即可
          builder.append(",為了找份好工作");
          System.out.println(builder);
          //替換方法：1.開始替換的下標 2.结束替換的下標(不包尾) 3.替換的内容
          builder.replace(9,builder.length(),"為了改變世界");
          System.out.println(builder);
          //删除方法: 1.開始删除的下標 2.结束删除的下標(不包尾)
          builder.delete(9,builder.length());
          System.out.println(builder);
          //插入方法: 1.開始插入的下標 2.要插入的内容
          builder.insert(9,"加油！~");
          System.out.println(builder);
          builder.reverse();//字符串反轉的方法
          System.out.println(builder);
          str = builder.toString();//將StringBuilder 類型轉換為 String類型
          System.out.println(str);
  ```

  **使用StringBuilder演示拼接效率的問題：**

  ```java
   String a = "a";
          StringBuilder builder = new StringBuilder(a);
          long start = System.currentTimeMillis();//獲取到當前時間(ms)
          for (int i = 0; i < 100000; i++) {
  //            a += "a";//拼接
              builder.append("a");//追加
          }
          long end = System.currentTimeMillis();
          System.out.println("運行時間是:"+(end - start)+"毫秒");
  ```

  ### 正則表達式

  ##### 適用性：當需要约束用戶輸入的内容必須滿足程序設定的格式時使用。

  ##### 例如：郵箱的正則,號碼的正則,身份證正則等等....

  ##### 基本正則表達式

  - ##### []   表示的是一個字符

  - ##### [a,b,c] 表示可以寫任意寫一個 a 或 b 或 c 

  - ##### [^abc] 表示處理a b c以外的任意一個字符

  - ##### [a-z]    表示可以寫26個字母中任意一個

  - ##### [a-zA-Z0-9] 表示的是可以寫一個26個小寫或大寫字母 或 任意一個數字。

    ```java
    [a-z&&[^bc]] 表示是除了bc以外的字母任意寫一個
    ```

  ##### 預定字符集

  - ##### .  表示是任意一個字符

  - ##### \d  表示可以寫0~9任意一個數字

  - ##### \w 表示可以寫任意一個字符 [a-zA-Z0-9]

  - ##### \s   表示寫一個空白字符

  - ##### \D  表示寫非數字字符

  - ##### \W 表示可以寫非數字,字母字符等

  - ##### \S  表示非空白字符

  ##### 數量詞

  ```java
  ?    表示可以寫0~1個字符
      例如：[abc]?  表示可以寫0 個 或1個 abc中任意一個字符
  +    表示至少寫1個 沒有上限
      例如:[abc]+   表示至少寫一個或多個 a b  c中任意字符
  *   表示可以寫任意次  
  -------------------------------
  限製次數
     [abc]{3}    只能寫3個字符
     [abc]{3,5}  至少寫3個字符 最多寫5個
     [abc]{3,}   至少寫3個字符 沒有上限
  ```

  分組

  ```java
  	(abc){3}  視為abc是一組 至少寫3組
      (abc|def){3} 視為abc 或 def為一組 至少出現3組
  ```

```java
//        String regex = "[a-zA-Z0-9_]+@[a-zA-Z0-9]+(\\.[a-zA-Z]+)+";
//        Scanner s = new Scanner(System.in);
//        System.out.println("請輸入您的郵箱");
//        String mail = s.next();//接收輸入的字符串内容
//        if (mail.matches(regex)) {//matches 方法是用來判斷字符串對象内容是否匹配傳入的正則格式
//            System.out.println("郵箱格式正確");
//        }else {
//            System.out.println("郵箱格式有誤！");
//        }
        //身份證號碼的正則格式：
                    //  或
        //身份證號碼  15  |  18
        //123456789012345       15位
        //123456789012345678    18位
        //12345678901234567x    17位數字 第18位x
        //12345678901234567X    17位數字 第18位X
        /**
         *   \d{15}    ----15位的數字
         *   \d{17}[\dxX] ----至少17位數字 後面可以是一個數字或字母X 或 x
         *   完整的格式:  \d{15}|\d{17}[\dxX]
         */
         String regex = "\\d{15}|\\d{17}[\\dxX]";
         String id = "12345678901234567X";
         if(id.matches(regex)){
             System.out.println("身份證格式正確");
         }else {
             System.out.println("錯誤");
         }
    }
		 //座機號碼的正則格式
        /**
         *  1234567    -----7位
         *  12345678   -----8位
         *  010-1234567 ----區號三位-7位
         *  010-12345678 ----區號三位-8位
         *  0101-1234567 ----區號四位-7位
         *  0101-12345678 ----區號四位-8位
         *  (010)1234567 ----區號三位7位
         *  (010)12345678 ----區號三位8位
         *  (0101)1234567 ----區號四位7位
         *  (0101)12345678 ----區號四位8位
         *  \d{7,8}   表示纯電話號碼
         *  區號第一種: \d{3,4}-
         *  區號第二種: (\d{3,4})
         *  完整格式: (\d{3,4}-|(\d{3,4}))?\d{7,8}
         */
        String regex = "(\\d{3,4}-|\\(\\d{3,4}\\))?\\d{7,8}";
        Scanner s = new Scanner(System.in);//創建一個掃描器
        System.out.println("輸入電話號碼:");
        String number=  s.next();
        if(number.matches(regex)){
            System.out.println("格式正確");
        }else {
            System.out.println("格式有誤");
        }
```

**StringAPI中支持正則的一些方法：**

```java
   split 切割的方法
//        String str = "abc123def456ghi789";
//        String[] strArr= str.split("[0-9]+");
//        System.out.println(strArr.length);
//        for (int i = 0; i < strArr.length; i++) {
//            System.out.println(strArr[i]);
//        }
//        str = "a@b@c@d@e@f";
//        strArr= str.split("@");
//        for (int i = 0; i < strArr.length; i++) {
//            System.out.println(strArr[i]);
//        }

        //-----------替換的方法---------------
        String regex ="(nc|tmd|sb|wc)";
        String message = "tmd!你這個nc,太sb了!";
        //replaceAll 1.正則格式 2.替換的内容
        message = message.replaceAll(regex,"*");
        System.out.println(message);
        String str = "abc123456def789";
        str = str.replaceAll("[0-9]+","NUMBER");
        System.out.println(str);
        //replace 方法不支持正則  從頭到尾檢索  檢索到内容後直接替換
        str = "abc123def456ghi789";
        str = str.replace("123","***");
        System.out.println(str);
```

### 設計模式

##### 遵循面向對象的設計原則,市面上常用23種設計模式,解决的則是設計上的問題.

##### 設計模式是軟件設計過程中,總结出來的一套經驗,可能更好的讓程序面向對象,設計模式一般應用在系統層,架構層面.

##### 常用的設計模式:單例設計模式,工廠,抽象工廠設計模式等...

#### 單例設計模式

##### 適用性:在程序中,工具是非常常用的,如果工具想要被使用,那麼首先要實例化對象再調用工具來使用.那麼對内存很大,所以推薦使用單例設計模式.

- ##### 餓漢式:不管外部有沒有調用我,我都提前把對象創建好

  ```java
  package singletondemo;
  
  import java.io.PrintStream;
  
  /**
   * 餓漢式單例模式:
   */
  public class HungrySingleton {
      public static void main(String[] args) {
  //        HungrySingletonDemo hungry = new HungrySingletonDemo();
  //        hungry.工具();
  //        HungrySingletonDemo hungry1 =  HungrySingletonDemo.getInstance();
  //        hungry1.工具();
  //        HungrySingletonDemo.getInstance().工具();
  
      }
  }
  /**
   * 餓漢式單例的實現:
   * 1.私有化構造方法 防止外部創建對象
   * 2.在類中自己創建一個對象
   * 3.對外提供一個全局訪問點的方法
   */
  class HungrySingletonDemo{//工具類
      private HungrySingletonDemo(){ }//1.
      private static HungrySingletonDemo hungry = new HungrySingletonDemo();//2.
      public static HungrySingletonDemo getInstance(){//3.
          return hungry;
      }
      public void 工具(){
          System.out.println("一個工具方法被執行了...");
      }
  }
  ```

- ##### 懶漢式: 在首次被使用的時候再去創建對象

  - ##### 優點: 避免内存浪費,不會提前創建對象

  - ##### 缺點: 存在線程安全的問題(第二階段線程相關内容).

  ```java
  package singletondemo;
  
  /**
   * 懶漢式單例模式演示類:
   */
  public class LazySingleton {
      public static void main(String[] args) {
          LazySingletonDemo.getInstance().工具();
      }
  }
  /**
   * 懶漢式單例步骤:
   * 1.私有化類的構造方法
   * 2.聲明了一個該類類型的静態變量
   * 3.對外提供全局唯一的訪問點
   */
  class LazySingletonDemo{
      private LazySingletonDemo(){}  //1.
      private static LazySingletonDemo lazy;//2.
      public static LazySingletonDemo getInstance(){//3.
          if(lazy == null){//如果對象為null
              lazy = new LazySingletonDemo(); //創建對象並賦值
          }
          return lazy;//返回對象
      }
      public void 工具(){
          System.out.println("一個工具方法執行了..");
      }
  }
  ```

#### Object類

##### Object類是所有類的父類,我們創建的類或Java中的類都直接或間接繼承Object類.

##### 開發Java的人認為以後創建的所有類,都會有一些共性的行為,Object作為父類提供一系列的结構支撑.

- ##### toString()

  - ##### 當如果一個類想要通過打印對象就能夠獲取到該對象的一些數據信息時,我們可以為該類重寫toString方法

  ```java
          Point p1 = new Point(1,2);
  //        System.out.println("x:"+p1.getX()+"y:"+p1.getY());
  
          //直接打印對象 輸出的是 類的全包名@内存地址
          //本質當直接輸出對象時,默認調用一個toString方法.
          //希望的是當打印對象時,可以將對象的數據信息輸出出來,而不是看對象的地址
          System.out.println(p1);
          int[] array = {10,40,50,60};
          System.out.println(Arrays.toString(array));
          String str = "ABC";
          System.out.println(str);//輸出對象的内容
  ```

  **point:**

  ```java
  package objectdemo;
  
  /**
   * 點
   */
  public class Point {
      private int x;
      private int y;
  
      public Point(int x, int y) {//類的構造方法
          this.x = x;
          this.y = y;
      }
      @Override
      public String toString() {
          return "Point{" + "x=" + x + ", y=" + y + '}';
      }
      public int getX() {//get獲取
          return x;
      }
      public void setX(int x) {//set設置
          this.x = x;
      }
      public int getY() {
          return y;
      }
      public void setY(int y) {
          this.y = y;
      }
  }
  ```

- ##### equals()

  - ##### 當如果引用類型中的對象需要進行對象與對象之間的内容比較,使用equals方法來比較,java中提供的功能類幾乎都是重寫equals方法. 自定義類型需要比較内容時,一定需要重寫equals方法

  ```java
   		Point p1 = new Point(1,2);
          Point p2 = new Point(1,2);
          System.out.println(p1 == p2);//false 比較的p1和p2是否相同.
          System.out.println(p1.getX()==p2.getX() && p1.getY() == p2.getY());//比較的對象中的數據是否相等
          boolean result = p1.equals(p2);
          System.out.println("使用重寫後的equals方法比較结果:"+result);
  
          String str1 = "ABC";
          String str2 = new String("ABC");
          System.out.println(str1 == str2);//雙等比較的是地址
          boolean r1=  str1.equals(str2);
          System.out.println("使用String重寫的equals方法比較结果:"+r1);
  ```

  point類重寫equals方法:

  ```java
  @Override
  public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || this.getClass() != o.getClass()) return false;
      Point point = (Point) o;
      return x == point.x && y == point.y;
  }
  
  @Override
  public int hashCode() {
      return Objects.hash(x, y);
  }
  ```

- #### 面試題:

  - ##### == 和 equals方法的區别?

    - #####  == 是關係運算符    -----返回结果boolean

    - ##### equals是方法         -----返回结果boolean

    - ##### == 在實際使用時:

      - ##### 對於基本數據類型來講,判斷的是兩個變量之間的數據是否相同

      - ##### 對於引用數據類型來講,判斷的是兩個對象之間的地址是否相同

      - ##### Object中的equals方法,本質上也是使用==來進行比較.

    - ##### equals在使用時:

      - ##### Java中所有的類幾乎都實現重寫了Object類中equals方法,根據自己的類型内容來進行比較

      - ##### 如果自定義的類型,沒有重寫equals方法,默認使用的還是Object類中提供的雙等判斷

      - ##### 我們可以自己根據需要在類中重寫equals方法,一般需要重寫hashCode方法,達到比較類型之間的内容是否相等

### 包裝類

##### java是面向對象的語言,為了讓基本數據類型能参與到面向對象的開發工作,所以Java對應了8種基本數據類型,設計了對應的包裝類類型.  目的:讓值可以以對象的形式存在.

> ##### java的基本數據類型八種：byte  short  int  long  float  double  char  boolean
>
> ```
> Byte
> Short
> Intege
> Long
> Float
> Double  這些包裝類 都繼承自Number
> character
> Boolean           繼承Object
> ```

- ##### valueOf()；

- ##### parseInt();

```java
package wrapclassdemo;

/**
 * 包裝類的使用演示類：
 */
public class WrapClassDemo {
    public static void main(String[] args) {
        /**  基本數據類型           包裝類
         *   byte                 Byte
         *   short                Short
         *   int                  Integer
         *   long                 Long
         *   float                Float
         *   double               Double
         *   char                 character
         *   boolean              Boolean
         */
        //基本數據類型 轉換為包裝類類型
        int number = 100;
        Integer i1 = new Integer(number);//不建議的轉換寫法
        Integer i2 = new Integer(number);
        System.out.println(i1 == i2);//false
        Integer i3 = Integer.valueOf(100); //建議的寫法   複用1個字節的缓存   -128~127
        Integer i4 = Integer.valueOf(100);
        System.out.println(i3 == i4);//true
        String str = "123";//不能亂寫  只能寫對應的數據
        Integer i5 = Integer.parseInt(str);//可以將傳入的字符串數值内容轉換為對應Integer類型
        System.out.println(i5);
        //包裝類類型 轉換為基本數據類型
        Integer i6 = Integer.valueOf(200);
        int number1 =  i6.intValue();
        System.out.println(number1);
        Double d1 = Double.valueOf(1.23);//Double.valueOf 沒有缓存 本質上還是創建對象
        double d2 = d1.doubleValue();
        System.out.println(d2);
        String str1 = "1.23";
        System.out.println(Double.parseDouble(str1));
        //拆裝箱  
    }
}
```

#### 自動拆裝箱

##### jdk1.5版本後推出一個新特性,編譯器支持基本數據類型和包裝類類型之間可以直接進行賦值,但是底層.class字節碼文件中,還是會补全轉換的語法。

##### 裝箱：將基本數據類型直接賦值给包裝類的過程

##### 拆箱：將包裝類類型直接賦值给基本數據類型過程。

```java
  //拆裝箱
        //裝箱：將基本數據類型直接賦值给包裝類的過程
        int i = 123;
        /**
         *   Integer integer = i;  字節碼文件中轉化為  Integer integer  = Integer.valueOf(i);
         */
        Integer integer = i;
        System.out.println(integer);
        //拆箱:將包裝類類型直接賦值给基本數據類型過程。
        /**
         *    int n = integer;    字節碼文件中轉化為  int n = integer.intValueOf();
         */
        int n = integer;
        System.out.println(n);
```

#### 面試題：什麼是拆箱,什麼是裝箱？拆裝箱的過程？

##### 答:

- ##### 裝箱:將基本數據類型賦值给包裝類類型過程

  - ##### 裝箱的執行過程：實際調用包裝類的valueOf方法來實現

    - ##### 例如：Integer i1 = Integer.valueOf(i);

- ##### 	 拆箱:將包裝類類型賦值给基本數據類型過程

  - ##### 拆箱的執行過程：調用包裝類對象的xxValue方法來實現

    - ##### 例如： int i2 =  i1.intValue();
    
      

# JAVASE

### 1. DAY01

#### 1.1 String 常用的 API

- length（） 方法用於返回字符串的長度，也就是字符串中字符的個數
- indexOf（）  方法用於查找指定字符或者子字符串在字符串中第一次出現的位置，如果找到，則返回該字符串或者子字符串的索引，如果未找到，則返回 -1
- chatAt（）方法用於獲取字符串中指定位置的字符，它接受一個整數參數，表示要獲取字符的索引，返回該位置的字符
- subString（）方法用於提取字符串中的子串，它接受一個或者兩個整數參數，表示子串的起始位置和結束位置，包頭不包尾
- toUpperCase（）方法用於將字符串中的所有字符轉換為大寫形式
- Trim（）方法用於去除字符串兩端的空白字符（空格，制表符，換行符等）返回一個新的字符串參數，該字符串是原字符串去除空白字符後的結果
- startsWith（）方法用於檢查字符串是否以指定的前綴開始，它接受一個字符串參數，如果原字符串以該前綴開始，則返回 true，否則，返回 false
- valueOf（）方法用於將其他類型的值轉換為字符串表示，它接受一個值作為參數，並返回表示該值的字符串。

#### 1.2 案例： URL格式驗證器

#### 案例描述:

- ##### 編寫一個程序，用於驗證用戶輸入的字符串是否符合URL的格式要求。程序將檢查字 符串的長度、是否以特定前綴開頭、是否包含特定字符，並輸出驗證結果給用戶。

#### URL 格式要求:

http://baidu.COM

- 要求 URL 的長度必須在 10 到 100 個字符之間 //true 

  -  length()方法檢查字符串的長度

- 兩端不允許有空格 //去除空格

  - trim() 方法去除字符串兩端的空格

- 並且是以 http:// 或者 https:// 開頭，以.com 結束 //true

  - startsWith()方法檢查是否是以 http://或者 https://開頭

  - endsWith()方法檢查字符串是否以 .com 結尾

- 不允許包含特殊的字符(&，#，?)// true

  - 使用 indexOf()方法檢查是否包含特殊字符
  - 要求全部都由小寫字母組成 //xiaoxie 

- 代碼實現:

  ```java
  package cn.tedu.demo01;
  
  import java.util.Scanner;
  
  public class URLValidator {
    	public static void main(String[] args) {
        
    			Scanner scanner = new Scanner(System.in); 
        	//用戶輸入字符串
    			System.out.println("請輸入字符串"); 
        	String next = scanner.next();
        
    			//驗證字符串 URL
    			boolean b = validateURL(next);
        
    			//輸出驗證結果 
        	if(b){
    					System.out.println("URL 驗證通過"); 
          }else{
    					System.out.println("URL 驗證失敗"); 
          }
    	}
    
    	public static boolean validateURL(String input){
        
    			//1. 要求 URL 的長度必須在 10 到 100 個字符之間 || 或 檢查字符串長度
    			if(input.length()<10 || input.length()>100){ 
            return false;
    			}
        
    			//2. 兩端不允許有空格 
        	input = input.trim();
        
    			//3. 並且是以 http:// 或者 https:// 開頭，以.com 結束 && 與
    			if(!input.startsWith("http://") || !input.startsWith("https://") && !input.endsWith(".com")){
            return false;
        }
        
    			//3.不允許包含特殊的字符(&，#，?)
    			if(input.indexOf("&")!=-1 || input.indexOf("#")!=-1 || input.indexOf("?")!=-1){
            return false;
        }
    //4. 全部都是以小寫字母組成 input = input.toLowerCase();
        return true;
      }
  }
  ```
  

### 2.DAY02

#### 2.1 StringBuffer 和 StringBuilder 的曲别(需要背)

##### StringBuffer 和 StringBuilder 是 Java 中用於處理可變字符串的類，它們之間的主要區 別在於它們的線程安全性和性能特性。

1. 線程安全性

   - StringBuffer是線程安全的，它的方法是同步的，可以在多線程環境下安全地使用 。這意味著多個線程可以同時訪問和修改同一個 StringBuffer 對象，而不會導致數據 不一致的問題。
   - StringBuilder不是線程安全的，它的方法是非同步的。在多線程環境下使用StringBuilder 需要額外的同步措施，否則可能導致數據不一致的問題。

2. 性能特性

   - StringBuffer的方法是同步的，這使得它在執行線程安全的操作時會產生一定的性 能開銷。因為它的方法會進行同步處理，確保在多線程環境下的數據一致性，但在單線 程環境下可能會比較耗費性能。

   - StringBuilder的方法是非同步的，它沒有線程安全的保證，因此在單線程環境下執 行操作時比StringBuilder更快速和高效。

3. 注意: 

   1. 除了線程安全性和性能特性之外，StringBuffer 和 StringBuilder的其他方法和用法是相同的，它們都提供了用於修改和操作字符串的一系列方法。
   2. 如果代碼在多線程環境下被訪問或者修改，或者需要線程安全的操作，那麽應該使用StringBuffer
   3. 如果代碼在單線程環境下執行，或者不需要線程安全的操作，並且對性能有較高的要求，那麽應該使用	StringBuilder

#### 2.2 包裝類

- 每一個八大基本數據類型都有對應的包裝類

-  在 JDK1.5 之後提出了自動拆裝箱的概念，用於基本數據類型和包裝類之間的相互轉換的過程。

- 拆箱:

  - 拆箱是指將包裝類對象轉換為對應的基本數據類型，同樣，Java也提供了自動拆箱的功能，也就在需要使用基本數據類型的地方，可以直接使用包裝類對象，而 Java 會自動將其拆箱為對應的基本數據類型

  - 例如: 將Integer對象拆箱為基本數據類型int

    ```java
    Integer integerObj = 20;
    int num = integerObj; // 自動拆箱
    ```

- 裝箱:

  - 裝箱是指將基本數據類型轉換為對應的包裝類對象。 Java提供了自動裝箱的功能，即在需要使用包裝類對象的地方，可以直接使用基本數據類型，而 Java 會自動將其轉換為對應的包裝類對象。

  - 例如，將基本數據類型int裝箱為Integer對象:

    ```java
    int num = 10;
    Integer integerObj = num; // 自動裝箱
    ```

#### 2.3 Object

- equals 方法
  - 在Object類中默認的equlas方法是通過==來進行比較的，默認比較的是對象的地址，如果想要比較對象的內容，則需要在自定義類中重寫 equals 方法 toString 方法
- toString 方法
  - 在輸出對象的時候，如果不重寫toString方法，則默認輸出的是當前對象的地址，如果需要輸出當前對象中屬性的值，則需要重寫 toString 方法。

#### 2.4 正則表達式

##### 正則表達式能夠描述字符串的格式，通常用於驗證字符串內容

-  一個字符

  [ ] 用於描述單一字符，方括號內部可以定義這個字符的內容，也可以描述一個範圍

  
